# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T12:21:38+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import (
    BaseModel,
    ConfigDict,
    Field,
    RootModel,
    SecretStr,
    confloat,
    conint,
    constr,
)


class Action(RootModel[constr(pattern=r'(lambda:[*]|lambda:[a-zA-Z]+|[*])')]):
    root: constr(pattern=r'(lambda:[*]|lambda:[a-zA-Z]+|[*])')


class AdditionalVersion(
    RootModel[constr(pattern=r'[0-9]+', min_length=1, max_length=1024)]
):
    root: constr(pattern=r'[0-9]+', min_length=1, max_length=1024)


class Alias(
    RootModel[
        constr(pattern=r'(?!^[0-9]+$)([a-zA-Z0-9-_]+)', min_length=1, max_length=128)
    ]
):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    root: constr(pattern=r'(?!^[0-9]+$)([a-zA-Z0-9-_]+)', min_length=1, max_length=128)


class AllowCredentials(RootModel[bool]):
    root: bool


class Architecture(Enum):
    x86_64 = 'x86_64'
    arm64 = 'arm64'


class ArchitecturesList(RootModel[List[Architecture]]):
    root: List[Architecture] = Field(..., max_length=1, min_length=1)


class Arn(
    RootModel[
        constr(
            pattern=r'arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)'
        )
    ]
):
    root: constr(
        pattern=r'arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)'
    )


class BatchSize(RootModel[conint(ge=1, le=10000)]):
    root: conint(ge=1, le=10000)


class BisectBatchOnFunctionError(RootModel[bool]):
    root: bool


class Blob(RootModel[SecretStr]):
    root: SecretStr


class BlobStream(RootModel[str]):
    root: str


class Boolean(RootModel[bool]):
    root: bool


class CodeSigningConfigArn(
    RootModel[
        constr(
            pattern=r'arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\d{1}:\d{12}:code-signing-config:csc-[a-z0-9]{17}',
            max_length=200,
        )
    ]
):
    root: constr(
        pattern=r'arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\d{1}:\d{12}:code-signing-config:csc-[a-z0-9]{17}',
        max_length=200,
    )


class CodeSigningConfigId(RootModel[constr(pattern=r'csc-[a-zA-Z0-9-_\.]{17}')]):
    root: constr(pattern=r'csc-[a-zA-Z0-9-_\.]{17}')


class CodeSigningConfigNotFoundException(RootModel[Any]):
    root: Any


class CodeSigningPolicy(Enum):
    Warn = 'Warn'
    Enforce = 'Enforce'


class CodeStorageExceededException(RootModel[Any]):
    root: Any


class CodeVerificationFailedException(RootModel[Any]):
    root: Any


class CollectionName(
    RootModel[
        constr(
            pattern=r'(^(?!(system\x2e)))(^[_a-zA-Z0-9])([^$]*)',
            min_length=1,
            max_length=57,
        )
    ]
):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    root: constr(
        pattern=r'(^(?!(system\x2e)))(^[_a-zA-Z0-9])([^$]*)',
        min_length=1,
        max_length=57,
    )


class CompatibleArchitectures(RootModel[List[Architecture]]):
    root: List[Architecture] = Field(..., max_length=2)


class DatabaseName(
    RootModel[constr(pattern=r'[^ /\.$\x22]*', min_length=1, max_length=63)]
):
    root: constr(pattern=r'[^ /\.$\x22]*', min_length=1, max_length=63)


class Date(RootModel[datetime]):
    root: datetime


class DeleteAliasRequest(BaseModel):
    pass


class DeleteCodeSigningConfigRequest(BaseModel):
    pass


class DeleteCodeSigningConfigResponse(BaseModel):
    pass


class DeleteEventSourceMappingRequest(BaseModel):
    pass


class DeleteFunctionCodeSigningConfigRequest(BaseModel):
    pass


class DeleteFunctionConcurrencyRequest(BaseModel):
    pass


class DeleteFunctionEventInvokeConfigRequest(BaseModel):
    pass


class DeleteFunctionRequest(BaseModel):
    pass


class DeleteFunctionUrlConfigRequest(BaseModel):
    pass


class DeleteLayerVersionRequest(BaseModel):
    pass


class DeleteProvisionedConcurrencyConfigRequest(BaseModel):
    pass


class Description(RootModel[constr(min_length=0, max_length=256)]):
    root: constr(min_length=0, max_length=256)


class DestinationArn(
    RootModel[
        constr(
            pattern=r'^$|arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)',
            min_length=0,
            max_length=350,
        )
    ]
):
    root: constr(
        pattern=r'^$|arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)',
        min_length=0,
        max_length=350,
    )


class EC2AccessDeniedException(RootModel[Any]):
    root: Any


class EC2ThrottledException(RootModel[Any]):
    root: Any


class EC2UnexpectedException(RootModel[Any]):
    root: Any


class EFSIOException(RootModel[Any]):
    root: Any


class EFSMountConnectivityException(RootModel[Any]):
    root: Any


class EFSMountFailureException(RootModel[Any]):
    root: Any


class EFSMountTimeoutException(RootModel[Any]):
    root: Any


class ENILimitReachedException(RootModel[Any]):
    root: Any


class Enabled(RootModel[bool]):
    root: bool


class EndPointType(Enum):
    KAFKA_BOOTSTRAP_SERVERS = 'KAFKA_BOOTSTRAP_SERVERS'


class Endpoint(
    RootModel[
        constr(
            pattern=r'^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9]):[0-9]{1,5}',
            min_length=1,
            max_length=300,
        )
    ]
):
    root: constr(
        pattern=r'^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9]):[0-9]{1,5}',
        min_length=1,
        max_length=300,
    )


class EndpointLists(RootModel[List[Endpoint]]):
    root: List[Endpoint] = Field(..., max_length=10, min_length=1)


class Endpoints(RootModel[Optional[Dict[str, EndpointLists]]]):
    root: Optional[Dict[str, EndpointLists]] = None


class EnvironmentVariableName(RootModel[SecretStr]):
    root: SecretStr


class EnvironmentVariableValue(RootModel[SecretStr]):
    root: SecretStr


class EnvironmentVariables(RootModel[Optional[Dict[str, EnvironmentVariableValue]]]):
    root: Optional[Dict[str, EnvironmentVariableValue]] = None


class EphemeralStorageSize(RootModel[conint(ge=512, le=10240)]):
    root: conint(ge=512, le=10240)


class EventSourcePosition(Enum):
    TRIM_HORIZON = 'TRIM_HORIZON'
    LATEST = 'LATEST'
    AT_TIMESTAMP = 'AT_TIMESTAMP'


class EventSourceToken(
    RootModel[constr(pattern=r'[a-zA-Z0-9._\-]+', min_length=0, max_length=256)]
):
    root: constr(pattern=r'[a-zA-Z0-9._\-]+', min_length=0, max_length=256)


class FileSystemArn(
    RootModel[
        constr(
            pattern=r'arn:aws[a-zA-Z-]*:elasticfilesystem:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\d{1}:\d{12}:access-point/fsap-[a-f0-9]{17}',
            max_length=200,
        )
    ]
):
    root: constr(
        pattern=r'arn:aws[a-zA-Z-]*:elasticfilesystem:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\d{1}:\d{12}:access-point/fsap-[a-f0-9]{17}',
        max_length=200,
    )


class FullDocument(Enum):
    UpdateLookup = 'UpdateLookup'
    Default = 'Default'


class FunctionArn(
    RootModel[
        constr(
            pattern=r'arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?'
        )
    ]
):
    root: constr(
        pattern=r'arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?'
    )


class FunctionArnList(RootModel[List[FunctionArn]]):
    root: List[FunctionArn]


class FunctionName(
    RootModel[
        constr(
            pattern=r'(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?',
            min_length=1,
            max_length=140,
        )
    ]
):
    root: constr(
        pattern=r'(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?',
        min_length=1,
        max_length=140,
    )


class FunctionResponseType(Enum):
    ReportBatchItemFailures = 'ReportBatchItemFailures'


class FunctionResponseTypeList(RootModel[List[FunctionResponseType]]):
    root: List[FunctionResponseType] = Field(..., max_length=1, min_length=0)


class FunctionUrl(RootModel[constr(min_length=40, max_length=100)]):
    root: constr(min_length=40, max_length=100)


class FunctionUrlAuthType(Enum):
    NONE = 'NONE'
    AWS_IAM = 'AWS_IAM'


class FunctionUrlQualifier(
    RootModel[
        constr(
            pattern=r'(^\$LATEST$)|((?!^[0-9]+$)([a-zA-Z0-9-_]+))',
            min_length=1,
            max_length=128,
        )
    ]
):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    root: constr(
        pattern=r'(^\$LATEST$)|((?!^[0-9]+$)([a-zA-Z0-9-_]+))',
        min_length=1,
        max_length=128,
    )


class FunctionVersion(Enum):
    ALL = 'ALL'


class GetAccountSettingsRequest(BaseModel):
    pass


class GetAliasRequest(BaseModel):
    pass


class GetCodeSigningConfigRequest(BaseModel):
    pass


class GetEventSourceMappingRequest(BaseModel):
    pass


class GetFunctionCodeSigningConfigRequest(BaseModel):
    pass


class GetFunctionCodeSigningConfigResponse(BaseModel):
    CodeSigningConfigArn_1: CodeSigningConfigArn = Field(
        ..., alias='CodeSigningConfigArn'
    )
    FunctionName_1: FunctionName = Field(..., alias='FunctionName')


class GetFunctionConcurrencyRequest(BaseModel):
    pass


class GetFunctionConfigurationRequest(BaseModel):
    pass


class GetFunctionEventInvokeConfigRequest(BaseModel):
    pass


class GetFunctionRequest(BaseModel):
    pass


class GetFunctionUrlConfigRequest(BaseModel):
    pass


class GetLayerVersionByArnRequest(BaseModel):
    pass


class GetLayerVersionPolicyRequest(BaseModel):
    pass


class GetLayerVersionRequest(BaseModel):
    pass


class GetPolicyRequest(BaseModel):
    pass


class GetProvisionedConcurrencyConfigRequest(BaseModel):
    pass


class GetRuntimeManagementConfigRequest(BaseModel):
    pass


class Handler(RootModel[constr(pattern=r'[^\s]+', max_length=128)]):
    root: constr(pattern=r'[^\s]+', max_length=128)


class Header(RootModel[constr(pattern=r'.*', max_length=1024)]):
    root: constr(pattern=r'.*', max_length=1024)


class HeadersList(RootModel[List[Header]]):
    root: List[Header] = Field(..., max_length=100)


class HttpStatus(RootModel[int]):
    root: int


class Integer(RootModel[int]):
    root: int


class InvalidCodeSignatureException(RootModel[Any]):
    root: Any


class InvalidParameterValueException(RootModel[Any]):
    root: Any


class InvalidRequestContentException(RootModel[Any]):
    root: Any


class InvalidRuntimeException(RootModel[Any]):
    root: Any


class InvalidSecurityGroupIDException(RootModel[Any]):
    root: Any


class InvalidSubnetIDException(RootModel[Any]):
    root: Any


class InvalidZipFileException(RootModel[Any]):
    root: Any


class InvocationRequest(BaseModel):
    Payload: Optional[Blob] = None


class InvocationResponse(BaseModel):
    Payload: Optional[Blob] = None
    StatusCode: Optional[Integer] = None


class InvocationType(Enum):
    Event = 'Event'
    RequestResponse = 'RequestResponse'
    DryRun = 'DryRun'


class InvokeAsyncRequest(BaseModel):
    InvokeArgs: BlobStream


class InvokeAsyncResponse(BaseModel):
    Status: Optional[HttpStatus] = None


class InvokeMode(Enum):
    BUFFERED = 'BUFFERED'
    RESPONSE_STREAM = 'RESPONSE_STREAM'


class InvokeResponseStreamUpdate(BaseModel):
    Payload: Optional[Blob] = None


class InvokeWithResponseStreamRequest(BaseModel):
    Payload: Optional[Blob] = None


class KMSAccessDeniedException(RootModel[Any]):
    root: Any


class KMSDisabledException(RootModel[Any]):
    root: Any


class KMSInvalidStateException(RootModel[Any]):
    root: Any


class KMSKeyArn(RootModel[constr(pattern=r'(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()')]):
    root: constr(pattern=r'(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()')


class KMSNotFoundException(RootModel[Any]):
    root: Any


class LastUpdateStatus(Enum):
    Successful = 'Successful'
    Failed = 'Failed'
    InProgress = 'InProgress'


class LastUpdateStatusReason(RootModel[str]):
    root: str


class LastUpdateStatusReasonCode(Enum):
    EniLimitExceeded = 'EniLimitExceeded'
    InsufficientRolePermissions = 'InsufficientRolePermissions'
    InvalidConfiguration = 'InvalidConfiguration'
    InternalError = 'InternalError'
    SubnetOutOfIPAddresses = 'SubnetOutOfIPAddresses'
    InvalidSubnet = 'InvalidSubnet'
    InvalidSecurityGroup = 'InvalidSecurityGroup'
    ImageDeleted = 'ImageDeleted'
    ImageAccessDenied = 'ImageAccessDenied'
    InvalidImage = 'InvalidImage'
    KMSKeyAccessDenied = 'KMSKeyAccessDenied'
    KMSKeyNotFound = 'KMSKeyNotFound'
    InvalidStateKMSKey = 'InvalidStateKMSKey'
    DisabledKMSKey = 'DisabledKMSKey'
    EFSIOError = 'EFSIOError'
    EFSMountConnectivityError = 'EFSMountConnectivityError'
    EFSMountFailure = 'EFSMountFailure'
    EFSMountTimeout = 'EFSMountTimeout'
    InvalidRuntime = 'InvalidRuntime'
    InvalidZipFileException = 'InvalidZipFileException'
    FunctionError = 'FunctionError'


class LayerArn(
    RootModel[
        constr(
            pattern=r'arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+',
            min_length=1,
            max_length=140,
        )
    ]
):
    root: constr(
        pattern=r'arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+',
        min_length=1,
        max_length=140,
    )


class LayerName(
    RootModel[
        constr(
            pattern=r'(arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+)|[a-zA-Z0-9-_]+',
            min_length=1,
            max_length=140,
        )
    ]
):
    root: constr(
        pattern=r'(arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+)|[a-zA-Z0-9-_]+',
        min_length=1,
        max_length=140,
    )


class LayerPermissionAllowedAction(
    RootModel[constr(pattern=r'lambda:GetLayerVersion', max_length=22)]
):
    root: constr(pattern=r'lambda:GetLayerVersion', max_length=22)


class LayerPermissionAllowedPrincipal(
    RootModel[constr(pattern=r'\d{12}|\*|arn:(aws[a-zA-Z-]*):iam::\d{12}:root')]
):
    root: constr(pattern=r'\d{12}|\*|arn:(aws[a-zA-Z-]*):iam::\d{12}:root')


class LayerVersionArn(
    RootModel[
        constr(
            pattern=r'arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+:[0-9]+',
            min_length=1,
            max_length=140,
        )
    ]
):
    root: constr(
        pattern=r'arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+:[0-9]+',
        min_length=1,
        max_length=140,
    )


class LayerVersionNumber(RootModel[int]):
    root: int


class LicenseInfo(RootModel[constr(max_length=512)]):
    root: constr(max_length=512)


class ListAliasesRequest(BaseModel):
    pass


class ListCodeSigningConfigsRequest(BaseModel):
    pass


class ListEventSourceMappingsRequest(BaseModel):
    pass


class ListFunctionEventInvokeConfigsRequest(BaseModel):
    pass


class ListFunctionUrlConfigsRequest(BaseModel):
    pass


class ListFunctionsByCodeSigningConfigRequest(BaseModel):
    pass


class ListFunctionsRequest(BaseModel):
    pass


class ListLayerVersionsRequest(BaseModel):
    pass


class ListLayersRequest(BaseModel):
    pass


class ListProvisionedConcurrencyConfigsRequest(BaseModel):
    pass


class ListTagsRequest(BaseModel):
    pass


class ListVersionsByFunctionRequest(BaseModel):
    pass


class LocalMountPath(
    RootModel[constr(pattern=r'^/mnt/[a-zA-Z0-9-_.]+$', max_length=160)]
):
    root: constr(pattern=r'^/mnt/[a-zA-Z0-9-_.]+$', max_length=160)


class LogType(Enum):
    None_ = 'None'
    Tail = 'Tail'


class Long(RootModel[int]):
    root: int


class MasterRegion(RootModel[constr(pattern=r'ALL|[a-z]{2}(-gov)?-[a-z]+-\d{1}')]):
    root: constr(pattern=r'ALL|[a-z]{2}(-gov)?-[a-z]+-\d{1}')


class MaxAge(RootModel[conint(ge=0, le=86400)]):
    root: conint(ge=0, le=86400)


class MaxFunctionEventInvokeConfigListItems(RootModel[conint(ge=1, le=50)]):
    root: conint(ge=1, le=50)


class MaxItems(RootModel[conint(ge=1, le=50)]):
    root: conint(ge=1, le=50)


class MaxLayerListItems(RootModel[conint(ge=1, le=50)]):
    root: conint(ge=1, le=50)


class MaxListItems(RootModel[conint(ge=1, le=10000)]):
    root: conint(ge=1, le=10000)


class MaxProvisionedConcurrencyConfigListItems(RootModel[conint(ge=1, le=50)]):
    root: conint(ge=1, le=50)


class MaximumBatchingWindowInSeconds(RootModel[conint(ge=0, le=300)]):
    root: conint(ge=0, le=300)


class MaximumConcurrency(RootModel[conint(ge=2, le=1000)]):
    root: conint(ge=2, le=1000)


class MaximumEventAgeInSeconds(RootModel[conint(ge=60, le=21600)]):
    root: conint(ge=60, le=21600)


class MaximumRecordAgeInSeconds(RootModel[conint(ge=-1, le=604800)]):
    root: conint(ge=-1, le=604800)


class MaximumRetryAttempts(RootModel[conint(ge=0, le=2)]):
    root: conint(ge=0, le=2)


class MaximumRetryAttemptsEventSourceMapping(RootModel[conint(ge=-1, le=10000)]):
    root: conint(ge=-1, le=10000)


class MemorySize(RootModel[conint(ge=128, le=10240)]):
    root: conint(ge=128, le=10240)


class Method(RootModel[constr(pattern=r'.*', max_length=6)]):
    root: constr(pattern=r'.*', max_length=6)


class NameSpacedFunctionArn(
    RootModel[
        constr(
            pattern=r'arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:\d{12}:function:[a-zA-Z0-9-_\.]+(:(\$LATEST|[a-zA-Z0-9-_]+))?'
        )
    ]
):
    root: constr(
        pattern=r'arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:\d{12}:function:[a-zA-Z0-9-_\.]+(:(\$LATEST|[a-zA-Z0-9-_]+))?'
    )


class NamespacedFunctionName(
    RootModel[
        constr(
            pattern=r'(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?',
            min_length=1,
            max_length=170,
        )
    ]
):
    root: constr(
        pattern=r'(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?',
        min_length=1,
        max_length=170,
    )


class NamespacedStatementId(
    RootModel[constr(pattern=r'([a-zA-Z0-9-_.]+)', min_length=1, max_length=100)]
):
    root: constr(pattern=r'([a-zA-Z0-9-_.]+)', min_length=1, max_length=100)


class NonNegativeInteger(RootModel[conint(ge=0)]):
    root: conint(ge=0)


class OnFailure(BaseModel):
    Destination: Optional[DestinationArn] = None


class OnSuccess(BaseModel):
    Destination: Optional[DestinationArn] = None


class OrganizationId(RootModel[constr(pattern=r'o-[a-z0-9]{10,32}', max_length=34)]):
    root: constr(pattern=r'o-[a-z0-9]{10,32}', max_length=34)


class Origin(RootModel[constr(pattern=r'.*', min_length=1, max_length=253)]):
    root: constr(pattern=r'.*', min_length=1, max_length=253)


class PackageType(Enum):
    Zip = 'Zip'
    Image = 'Image'


class ParallelizationFactor(RootModel[conint(ge=1, le=10)]):
    root: conint(ge=1, le=10)


class Pattern(RootModel[constr(pattern=r'.*', min_length=0, max_length=4096)]):
    root: constr(pattern=r'.*', min_length=0, max_length=4096)


class PolicyLengthExceededException(RootModel[Any]):
    root: Any


class PositiveInteger(RootModel[conint(ge=1)]):
    root: conint(ge=1)


class PreconditionFailedException(RootModel[Any]):
    root: Any


class Principal(RootModel[constr(pattern=r'[^\s]+')]):
    root: constr(pattern=r'[^\s]+')


class PrincipalOrgID(
    RootModel[constr(pattern=r'^o-[a-z0-9]{10,32}$', min_length=12, max_length=34)]
):
    root: constr(pattern=r'^o-[a-z0-9]{10,32}$', min_length=12, max_length=34)


class ProvisionedConcurrencyConfigNotFoundException(RootModel[Any]):
    root: Any


class ProvisionedConcurrencyStatusEnum(Enum):
    IN_PROGRESS = 'IN_PROGRESS'
    READY = 'READY'
    FAILED = 'FAILED'


class PutFunctionCodeSigningConfigRequest(BaseModel):
    CodeSigningConfigArn_1: CodeSigningConfigArn = Field(
        ..., alias='CodeSigningConfigArn'
    )


class PutFunctionCodeSigningConfigResponse(BaseModel):
    CodeSigningConfigArn_1: CodeSigningConfigArn = Field(
        ..., alias='CodeSigningConfigArn'
    )
    FunctionName_1: FunctionName = Field(..., alias='FunctionName')


class PutProvisionedConcurrencyConfigRequest(BaseModel):
    ProvisionedConcurrentExecutions: PositiveInteger


class Qualifier(
    RootModel[constr(pattern=r'(|[a-zA-Z0-9$_-]+)', min_length=1, max_length=128)]
):
    root: constr(pattern=r'(|[a-zA-Z0-9$_-]+)', min_length=1, max_length=128)


class Queue(RootModel[constr(pattern=r'[\s\S]*', min_length=1, max_length=1000)]):
    root: constr(pattern=r'[\s\S]*', min_length=1, max_length=1000)


class Queues(RootModel[List[Queue]]):
    root: List[Queue] = Field(..., max_length=1, min_length=1)


class RemoveLayerVersionPermissionRequest(BaseModel):
    pass


class RemovePermissionRequest(BaseModel):
    pass


class RequestTooLargeException(RootModel[Any]):
    root: Any


class ReservedConcurrentExecutions(RootModel[conint(ge=0)]):
    root: conint(ge=0)


class ResourceArn(
    RootModel[constr(pattern=r'(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()')]
):
    root: constr(pattern=r'(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()')


class ResourceConflictException(RootModel[Any]):
    root: Any


class ResourceInUseException(RootModel[Any]):
    root: Any


class ResourceNotFoundException(RootModel[Any]):
    root: Any


class ResourceNotReadyException(RootModel[Any]):
    root: Any


class ResponseStreamingInvocationType(Enum):
    RequestResponse = 'RequestResponse'
    DryRun = 'DryRun'


class RoleArn(
    RootModel[
        constr(pattern=r'arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+')
    ]
):
    root: constr(
        pattern=r'arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+'
    )


class Runtime(Enum):
    nodejs = 'nodejs'
    nodejs4_3 = 'nodejs4.3'
    nodejs6_10 = 'nodejs6.10'
    nodejs8_10 = 'nodejs8.10'
    nodejs10_x = 'nodejs10.x'
    nodejs12_x = 'nodejs12.x'
    nodejs14_x = 'nodejs14.x'
    nodejs16_x = 'nodejs16.x'
    java8 = 'java8'
    java8_al2 = 'java8.al2'
    java11 = 'java11'
    python2_7 = 'python2.7'
    python3_6 = 'python3.6'
    python3_7 = 'python3.7'
    python3_8 = 'python3.8'
    python3_9 = 'python3.9'
    dotnetcore1_0 = 'dotnetcore1.0'
    dotnetcore2_0 = 'dotnetcore2.0'
    dotnetcore2_1 = 'dotnetcore2.1'
    dotnetcore3_1 = 'dotnetcore3.1'
    dotnet6 = 'dotnet6'
    nodejs4_3_edge = 'nodejs4.3-edge'
    go1_x = 'go1.x'
    ruby2_5 = 'ruby2.5'
    ruby2_7 = 'ruby2.7'
    provided = 'provided'
    provided_al2 = 'provided.al2'
    nodejs18_x = 'nodejs18.x'
    python3_10 = 'python3.10'


class RuntimeVersionArn(
    RootModel[
        constr(
            pattern=r'^arn:(aws[a-zA-Z-]*):lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\d{1}::runtime:.+$',
            min_length=26,
            max_length=2048,
        )
    ]
):
    root: constr(
        pattern=r'^arn:(aws[a-zA-Z-]*):lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\d{1}::runtime:.+$',
        min_length=26,
        max_length=2048,
    )


class S3Bucket(
    RootModel[
        constr(pattern=r'^[0-9A-Za-z\.\-_]*(?<!\.)$', min_length=3, max_length=63)
    ]
):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    root: constr(pattern=r'^[0-9A-Za-z\.\-_]*(?<!\.)$', min_length=3, max_length=63)


class S3Key(RootModel[constr(min_length=1, max_length=1024)]):
    root: constr(min_length=1, max_length=1024)


class S3ObjectVersion(RootModel[constr(min_length=1, max_length=1024)]):
    root: constr(min_length=1, max_length=1024)


class ScalingConfig(BaseModel):
    MaximumConcurrency_1: Optional[MaximumConcurrency] = Field(
        None, alias='MaximumConcurrency'
    )


class SecurityGroupId(RootModel[str]):
    root: str


class SecurityGroupIds(RootModel[List[SecurityGroupId]]):
    root: List[SecurityGroupId] = Field(..., max_length=5)


class SelfManagedEventSource(BaseModel):
    Endpoints_1: Optional[Endpoints] = Field(None, alias='Endpoints')


class SensitiveString(RootModel[SecretStr]):
    root: SecretStr


class ServiceException(RootModel[Any]):
    root: Any


class SigningProfileVersionArns(RootModel[List[Arn]]):
    root: List[Arn] = Field(..., max_length=20, min_length=1)


class SnapStartApplyOn(Enum):
    PublishedVersions = 'PublishedVersions'
    None_ = 'None'


class SnapStartException(RootModel[Any]):
    root: Any


class SnapStartNotReadyException(RootModel[Any]):
    root: Any


class SnapStartOptimizationStatus(Enum):
    On = 'On'
    Off = 'Off'


class SnapStartResponse(BaseModel):
    ApplyOn: Optional[SnapStartApplyOn] = None
    OptimizationStatus: Optional[SnapStartOptimizationStatus] = None


class SnapStartTimeoutException(RootModel[Any]):
    root: Any


class SourceAccessType(Enum):
    BASIC_AUTH = 'BASIC_AUTH'
    VPC_SUBNET = 'VPC_SUBNET'
    VPC_SECURITY_GROUP = 'VPC_SECURITY_GROUP'
    SASL_SCRAM_512_AUTH = 'SASL_SCRAM_512_AUTH'
    SASL_SCRAM_256_AUTH = 'SASL_SCRAM_256_AUTH'
    VIRTUAL_HOST = 'VIRTUAL_HOST'
    CLIENT_CERTIFICATE_TLS_AUTH = 'CLIENT_CERTIFICATE_TLS_AUTH'
    SERVER_ROOT_CA_CERTIFICATE = 'SERVER_ROOT_CA_CERTIFICATE'


class SourceOwner(RootModel[constr(pattern=r'\d{12}', max_length=12)]):
    root: constr(pattern=r'\d{12}', max_length=12)


class State(Enum):
    Pending = 'Pending'
    Active = 'Active'
    Inactive = 'Inactive'
    Failed = 'Failed'


class StateReason(RootModel[str]):
    root: str


class StateReasonCode(Enum):
    Idle = 'Idle'
    Creating = 'Creating'
    Restoring = 'Restoring'
    EniLimitExceeded = 'EniLimitExceeded'
    InsufficientRolePermissions = 'InsufficientRolePermissions'
    InvalidConfiguration = 'InvalidConfiguration'
    InternalError = 'InternalError'
    SubnetOutOfIPAddresses = 'SubnetOutOfIPAddresses'
    InvalidSubnet = 'InvalidSubnet'
    InvalidSecurityGroup = 'InvalidSecurityGroup'
    ImageDeleted = 'ImageDeleted'
    ImageAccessDenied = 'ImageAccessDenied'
    InvalidImage = 'InvalidImage'
    KMSKeyAccessDenied = 'KMSKeyAccessDenied'
    KMSKeyNotFound = 'KMSKeyNotFound'
    InvalidStateKMSKey = 'InvalidStateKMSKey'
    DisabledKMSKey = 'DisabledKMSKey'
    EFSIOError = 'EFSIOError'
    EFSMountConnectivityError = 'EFSMountConnectivityError'
    EFSMountFailure = 'EFSMountFailure'
    EFSMountTimeout = 'EFSMountTimeout'
    InvalidRuntime = 'InvalidRuntime'
    InvalidZipFileException = 'InvalidZipFileException'
    FunctionError = 'FunctionError'


class StatementId(
    RootModel[constr(pattern=r'([a-zA-Z0-9-_]+)', min_length=1, max_length=100)]
):
    root: constr(pattern=r'([a-zA-Z0-9-_]+)', min_length=1, max_length=100)


class String(RootModel[str]):
    root: str


class StringList(RootModel[List[String]]):
    root: List[String] = Field(..., max_length=1500)


class SubnetIPAddressLimitReachedException(RootModel[Any]):
    root: Any


class SubnetId(RootModel[str]):
    root: str


class SubnetIds(RootModel[List[SubnetId]]):
    root: List[SubnetId] = Field(..., max_length=16)


class TagKey(RootModel[str]):
    root: str


class TagKeyList(RootModel[List[TagKey]]):
    root: List[TagKey]


class TagValue(RootModel[str]):
    root: str


class Tags(RootModel[Optional[Dict[str, TagValue]]]):
    root: Optional[Dict[str, TagValue]] = None


class Timeout(RootModel[conint(ge=1)]):
    root: conint(ge=1)


class Timestamp(RootModel[str]):
    root: str


class TooManyRequestsException(RootModel[Any]):
    root: Any


class Topic(
    RootModel[constr(pattern=r'^[^.]([a-zA-Z0-9\-_.]+)', min_length=1, max_length=249)]
):
    root: constr(pattern=r'^[^.]([a-zA-Z0-9\-_.]+)', min_length=1, max_length=249)


class Topics(RootModel[List[Topic]]):
    root: List[Topic] = Field(..., max_length=1, min_length=1)


class TracingMode(Enum):
    Active = 'Active'
    PassThrough = 'PassThrough'


class TumblingWindowInSeconds(RootModel[conint(ge=0, le=900)]):
    root: conint(ge=0, le=900)


class URI(
    RootModel[constr(pattern=r'[a-zA-Z0-9-\/*:_+=.@-]*', min_length=1, max_length=200)]
):
    root: constr(pattern=r'[a-zA-Z0-9-\/*:_+=.@-]*', min_length=1, max_length=200)


class UnreservedConcurrentExecutions(RootModel[conint(ge=0)]):
    root: conint(ge=0)


class UnsupportedMediaTypeException(RootModel[Any]):
    root: Any


class UntagResourceRequest(BaseModel):
    pass


class UpdateFunctionCodeRequest(BaseModel):
    Architectures: Optional[ArchitecturesList] = None
    DryRun: Optional[Boolean] = None
    ImageUri: Optional[String] = None
    Publish: Optional[Boolean] = None
    RevisionId: Optional[String] = None
    S3Bucket_1: Optional[S3Bucket] = Field(None, alias='S3Bucket')
    S3Key_1: Optional[S3Key] = Field(None, alias='S3Key')
    S3ObjectVersion_1: Optional[S3ObjectVersion] = Field(None, alias='S3ObjectVersion')
    ZipFile: Optional[Blob] = None


class UpdateRuntimeOn(Enum):
    Auto = 'Auto'
    Manual = 'Manual'
    FunctionUpdate = 'FunctionUpdate'


class Version(
    RootModel[constr(pattern=r'(\$LATEST|[0-9]+)', min_length=1, max_length=1024)]
):
    root: constr(pattern=r'(\$LATEST|[0-9]+)', min_length=1, max_length=1024)


class VpcConfig(BaseModel):
    SecurityGroupIds_1: Optional[SecurityGroupIds] = Field(
        None, alias='SecurityGroupIds'
    )
    SubnetIds_1: Optional[SubnetIds] = Field(None, alias='SubnetIds')


class VpcId(RootModel[str]):
    root: str


class Weight(RootModel[confloat(ge=0.0, le=1.0)]):
    root: confloat(ge=0.0, le=1.0)


class WorkingDirectory(RootModel[constr(max_length=1000)]):
    root: constr(max_length=1000)


class Field20141113FunctionsFunctionNameInvokeAsyncPostRequest(BaseModel):
    InvokeArgs: str = Field(
        ...,
        description='The JSON that you want to provide to your Lambda function as input.',
    )


class AmazonManagedKafkaEventSourceConfig(BaseModel):
    ConsumerGroupId: Optional[URI] = None


class DestinationConfig(BaseModel):
    OnFailure_1: Optional[OnFailure] = Field(None, alias='OnFailure')
    OnSuccess_1: Optional[OnSuccess] = Field(None, alias='OnSuccess')


class DocumentDBEventSourceConfig(BaseModel):
    CollectionName_1: Optional[CollectionName] = Field(None, alias='CollectionName')
    DatabaseName_1: Optional[DatabaseName] = Field(None, alias='DatabaseName')
    FullDocument_1: Optional[FullDocument] = Field(None, alias='FullDocument')


class SelfManagedKafkaEventSourceConfig(BaseModel):
    ConsumerGroupId: Optional[URI] = None


class StartingPosition(Enum):
    TRIM_HORIZON = 'TRIM_HORIZON'
    LATEST = 'LATEST'
    AT_TIMESTAMP = 'AT_TIMESTAMP'


class Code(BaseModel):
    ImageUri: Optional[String] = None
    S3Bucket_1: Optional[S3Bucket] = Field(None, alias='S3Bucket')
    S3Key_1: Optional[S3Key] = Field(None, alias='S3Key')
    S3ObjectVersion_1: Optional[S3ObjectVersion] = Field(None, alias='S3ObjectVersion')
    ZipFile: Optional[Blob] = None


class DeadLetterConfig(BaseModel):
    TargetArn: Optional[ResourceArn] = None


class Environment(BaseModel):
    Variables: Optional[EnvironmentVariables] = None


class EphemeralStorage1(BaseModel):
    Size: Optional[EphemeralStorageSize] = None


class ImageConfig(BaseModel):
    Command: Optional[StringList] = None
    EntryPoint: Optional[StringList] = None
    WorkingDirectory_1: Optional[WorkingDirectory] = Field(
        None, alias='WorkingDirectory'
    )


class SnapStart(BaseModel):
    ApplyOn: Optional[SnapStartApplyOn] = None


class TracingConfig(BaseModel):
    Mode: Optional[TracingMode] = None


class Field20150331FunctionsFunctionNameCodePutRequest(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    Architectures: Optional[List[Architecture]] = Field(
        None,
        description='The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64). The default value is <code>x86_64</code>.',
        max_length=1,
        min_length=1,
    )
    DryRun: Optional[bool] = Field(
        None,
        description='Set to true to validate the request parameters and access permissions without modifying the function code.',
    )
    ImageUri: Optional[str] = Field(
        None,
        description='URI of a container image in the Amazon ECR registry. Do not use for a function defined with a .zip file archive.',
    )
    Publish: Optional[bool] = Field(
        None,
        description='Set to true to publish a new version of the function after updating the code. This has the same effect as calling <a>PublishVersion</a> separately.',
    )
    RevisionId: Optional[str] = Field(
        None,
        description="Update the function only if the revision ID matches the ID that's specified. Use this option to avoid modifying a function that has changed since you last read it.",
    )
    S3Bucket: Optional[
        constr(pattern=r'^[0-9A-Za-z\.\-_]*(?<!\.)$', min_length=3, max_length=63)
    ] = Field(
        None,
        description='An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account. Use only with a function defined with a .zip file archive deployment package.',
    )
    S3Key: Optional[constr(min_length=1, max_length=1024)] = Field(
        None,
        description='The Amazon S3 key of the deployment package. Use only with a function defined with a .zip file archive deployment package.',
    )
    S3ObjectVersion: Optional[constr(min_length=1, max_length=1024)] = Field(
        None,
        description='For versioned objects, the version of the deployment package object to use.',
    )
    ZipFile: Optional[SecretStr] = Field(
        None,
        description='The base64-encoded contents of the deployment package. Amazon Web Services SDK and CLI clients handle the encoding for you. Use only with a function defined with a .zip file archive deployment package.',
    )


class Field20150331FunctionsFunctionNameInvocationsPostRequest(BaseModel):
    Payload: Optional[SecretStr] = Field(
        None,
        description='<p>The JSON that you want to provide to your Lambda function as input.</p> <p>You can enter the JSON directly. For example, <code>--payload \'{ "key": "value" }\'</code>. You can also specify a file path. For example, <code>--payload file://payload.json</code>.</p>',
    )


class XAmzInvocationType(Enum):
    Event = 'Event'
    RequestResponse = 'RequestResponse'
    DryRun = 'DryRun'


class XAmzLogType(Enum):
    None_ = 'None'
    Tail = 'Tail'


class Field20150331FunctionsFunctionNamePolicyPostRequest(BaseModel):
    Action: constr(pattern=r'(lambda:[*]|lambda:[a-zA-Z]+|[*])') = Field(
        ...,
        description='The action that the principal can use on the function. For example, <code>lambda:InvokeFunction</code> or <code>lambda:GetFunction</code>.',
    )
    EventSourceToken: Optional[
        constr(pattern=r'[a-zA-Z0-9._\-]+', min_length=0, max_length=256)
    ] = Field(
        None,
        description='For Alexa Smart Home functions, a token that the invoker must supply.',
    )
    FunctionUrlAuthType_1: Optional[FunctionUrlAuthType] = Field(
        None,
        alias='FunctionUrlAuthType',
        description='The type of authentication that your function URL uses. Set to <code>AWS_IAM</code> if you want to restrict access to authenticated users only. Set to <code>NONE</code> if you want to bypass IAM authentication to create a public endpoint. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html">Security and auth model for Lambda function URLs</a>.',
    )
    Principal: constr(pattern=r'[^\s]+') = Field(
        ...,
        description='The Amazon Web Service or Amazon Web Services account that invokes the function. If you specify a service, use <code>SourceArn</code> or <code>SourceAccount</code> to limit who can invoke the function through that service.',
    )
    PrincipalOrgID: Optional[
        constr(pattern=r'^o-[a-z0-9]{10,32}$', min_length=12, max_length=34)
    ] = Field(
        None,
        description='The identifier for your organization in Organizations. Use this to grant permissions to all the Amazon Web Services accounts under this organization.',
    )
    RevisionId: Optional[str] = Field(
        None,
        description="Update the policy only if the revision ID matches the ID that's specified. Use this option to avoid modifying a policy that has changed since you last read it.",
    )
    SourceAccount: Optional[constr(pattern=r'\d{12}', max_length=12)] = Field(
        None,
        description='For Amazon Web Service, the ID of the Amazon Web Services account that owns the resource. Use this together with <code>SourceArn</code> to ensure that the specified account owns the resource. It is possible for an Amazon S3 bucket to be deleted by its owner and recreated by another account.',
    )
    SourceArn: Optional[
        constr(
            pattern=r'arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)'
        )
    ] = Field(
        None,
        description='<p>For Amazon Web Services, the ARN of the Amazon Web Services resource that invokes the function. For example, an Amazon S3 bucket or Amazon SNS topic.</p> <p>Note that Lambda configures the comparison using the <code>StringLike</code> operator.</p>',
    )
    StatementId: constr(pattern=r'([a-zA-Z0-9-_]+)', min_length=1, max_length=100) = (
        Field(
            ...,
            description='A statement identifier that differentiates the statement from others in the same policy.',
        )
    )


class Field20150331FunctionsFunctionNameVersionsPostRequest(BaseModel):
    CodeSha256: Optional[str] = Field(
        None,
        description="Only publish a version if the hash value matches the value that's specified. Use this option to avoid publishing a version if the function code has changed since you last updated it. You can get the hash for the version that you uploaded from the output of <a>UpdateFunctionCode</a>.",
    )
    Description: Optional[constr(min_length=0, max_length=256)] = Field(
        None,
        description='A description for the version to override the description in the function configuration.',
    )
    RevisionId: Optional[str] = Field(
        None,
        description="Only update the function if the revision ID matches the ID that's specified. Use this option to avoid publishing a version if the function configuration has changed since you last updated it.",
    )


class Field20170331TagsARNPostRequest(BaseModel):
    Tags: Dict[str, TagValue] = Field(
        ..., description='A list of tags to apply to the function.'
    )


class TagKeys(RootModel[List[TagKey]]):
    root: List[TagKey]


class Field20171031FunctionsFunctionNameConcurrencyPutRequest(BaseModel):
    ReservedConcurrentExecutions: conint(ge=0) = Field(
        ...,
        description='The number of simultaneous executions to reserve for the function.',
    )


class CompatibleRuntime(Enum):
    nodejs = 'nodejs'
    nodejs4_3 = 'nodejs4.3'
    nodejs6_10 = 'nodejs6.10'
    nodejs8_10 = 'nodejs8.10'
    nodejs10_x = 'nodejs10.x'
    nodejs12_x = 'nodejs12.x'
    nodejs14_x = 'nodejs14.x'
    nodejs16_x = 'nodejs16.x'
    java8 = 'java8'
    java8_al2 = 'java8.al2'
    java11 = 'java11'
    python2_7 = 'python2.7'
    python3_6 = 'python3.6'
    python3_7 = 'python3.7'
    python3_8 = 'python3.8'
    python3_9 = 'python3.9'
    dotnetcore1_0 = 'dotnetcore1.0'
    dotnetcore2_0 = 'dotnetcore2.0'
    dotnetcore2_1 = 'dotnetcore2.1'
    dotnetcore3_1 = 'dotnetcore3.1'
    dotnet6 = 'dotnet6'
    nodejs4_3_edge = 'nodejs4.3-edge'
    go1_x = 'go1.x'
    ruby2_5 = 'ruby2.5'
    ruby2_7 = 'ruby2.7'
    provided = 'provided'
    provided_al2 = 'provided.al2'
    nodejs18_x = 'nodejs18.x'
    python3_10 = 'python3.10'


class CompatibleArchitecture(Enum):
    x86_64 = 'x86_64'
    arm64 = 'arm64'


class Find(Enum):
    LayerVersion = 'LayerVersion'


class Content(BaseModel):
    S3Bucket_1: Optional[S3Bucket] = Field(None, alias='S3Bucket')
    S3Key_1: Optional[S3Key] = Field(None, alias='S3Key')
    S3ObjectVersion_1: Optional[S3ObjectVersion] = Field(None, alias='S3ObjectVersion')
    ZipFile: Optional[Blob] = None


class Field20181031LayersLayerNameVersionsPostRequest(BaseModel):
    CompatibleArchitectures: Optional[List[Architecture]] = Field(
        None,
        description='A list of compatible <a href="https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html">instruction set architectures</a>.',
        max_length=2,
    )
    CompatibleRuntimes: Optional[List[Runtime]] = Field(
        None,
        description='A list of compatible <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html">function runtimes</a>. Used for filtering with <a>ListLayers</a> and <a>ListLayerVersions</a>.',
        max_length=15,
    )
    Content_1: Content = Field(
        ...,
        alias='Content',
        description='A ZIP archive that contains the contents of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">Lambda layer</a>. You can specify either an Amazon S3 location, or upload a layer archive directly.',
    )
    Description: Optional[constr(min_length=0, max_length=256)] = Field(
        None, description='The description of the version.'
    )
    LicenseInfo: Optional[constr(max_length=512)] = Field(
        None,
        description='<p>The layer\'s software license. It can be any of the following:</p> <ul> <li> <p>An <a href="https://spdx.org/licenses/">SPDX license identifier</a>. For example, <code>MIT</code>.</p> </li> <li> <p>The URL of a license hosted on the internet. For example, <code>https://opensource.org/licenses/MIT</code>.</p> </li> <li> <p>The full text of the license.</p> </li> </ul>',
    )


class Field20181031LayersLayerNameVersionsVersionNumberPolicyPostRequest(BaseModel):
    Action: constr(pattern=r'lambda:GetLayerVersion', max_length=22) = Field(
        ...,
        description='The API action that grants access to the layer. For example, <code>lambda:GetLayerVersion</code>.',
    )
    OrganizationId: Optional[constr(pattern=r'o-[a-z0-9]{10,32}', max_length=34)] = (
        Field(
            None,
            description='With the principal set to <code>*</code>, grant permission to all accounts in the specified organization.',
        )
    )
    Principal: constr(pattern=r'\d{12}|\*|arn:(aws[a-zA-Z-]*):iam::\d{12}:root') = (
        Field(
            ...,
            description='An account ID, or <code>*</code> to grant layer usage permission to all accounts in an organization, or all Amazon Web Services accounts (if <code>organizationId</code> is not specified). For the last case, make sure that you really do want all Amazon Web Services accounts to have usage permission to this layer. ',
        )
    )
    StatementId: constr(pattern=r'([a-zA-Z0-9-_]+)', min_length=1, max_length=100) = (
        Field(
            ...,
            description='An identifier that distinguishes the policy from others on the same layer version.',
        )
    )


class Field20190925FunctionsFunctionNameEventInvokeConfigPostRequest(BaseModel):
    DestinationConfig_1: Optional[DestinationConfig] = Field(
        None,
        alias='DestinationConfig',
        description='A configuration object that specifies the destination of an event after Lambda processes it.',
    )
    MaximumEventAgeInSeconds: Optional[conint(ge=60, le=21600)] = Field(
        None,
        description='The maximum age of a request that Lambda sends to a function for processing.',
    )
    MaximumRetryAttempts: Optional[conint(ge=0, le=2)] = Field(
        None,
        description='The maximum number of times to retry when the function returns an error.',
    )


class Field20190925FunctionsFunctionNameEventInvokeConfigPutRequest(BaseModel):
    DestinationConfig_1: Optional[DestinationConfig] = Field(
        None,
        alias='DestinationConfig',
        description='A configuration object that specifies the destination of an event after Lambda processes it.',
    )
    MaximumEventAgeInSeconds: Optional[conint(ge=60, le=21600)] = Field(
        None,
        description='The maximum age of a request that Lambda sends to a function for processing.',
    )
    MaximumRetryAttempts: Optional[conint(ge=0, le=2)] = Field(
        None,
        description='The maximum number of times to retry when the function returns an error.',
    )


class ListModel(Enum):
    ALL = 'ALL'


class Field20190930FunctionsFunctionNameProvisionedConcurrencyQualifierPutRequest(
    BaseModel
):
    ProvisionedConcurrentExecutions: conint(ge=1) = Field(
        ...,
        description='The amount of provisioned concurrency to allocate for the version or alias.',
    )


class AllowedPublishers1(BaseModel):
    SigningProfileVersionArns_1: Optional[SigningProfileVersionArns] = Field(
        None, alias='SigningProfileVersionArns'
    )


class CodeSigningPolicies(BaseModel):
    UntrustedArtifactOnDeployment: Optional[CodeSigningPolicy] = None


class Field20200422CodeSigningConfigsPostRequest(BaseModel):
    AllowedPublishers: AllowedPublishers1 = Field(
        ..., description='List of signing profiles that can sign a code package. '
    )
    CodeSigningPolicies_1: Optional[CodeSigningPolicies] = Field(
        None,
        alias='CodeSigningPolicies',
        description='Code signing configuration <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-codesigning.html#config-codesigning-policies">policies</a> specify the validation failure action for signature mismatch or expiry.',
    )
    Description: Optional[constr(min_length=0, max_length=256)] = Field(
        None, description='Descriptive name for this code signing configuration.'
    )


class Field20200422CodeSigningConfigsCodeSigningConfigArnPutRequest(BaseModel):
    AllowedPublishers: Optional[AllowedPublishers1] = Field(
        None, description='List of signing profiles that can sign a code package. '
    )
    CodeSigningPolicies_1: Optional[CodeSigningPolicies] = Field(
        None,
        alias='CodeSigningPolicies',
        description='Code signing configuration <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-codesigning.html#config-codesigning-policies">policies</a> specify the validation failure action for signature mismatch or expiry.',
    )
    Description: Optional[constr(min_length=0, max_length=256)] = Field(
        None, description='Descriptive name for this code signing configuration.'
    )


class Field20200630FunctionsFunctionNameCodeSigningConfigPutRequest(BaseModel):
    CodeSigningConfigArn: constr(
        pattern=r'arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\d{1}:\d{12}:code-signing-config:csc-[a-z0-9]{17}',
        max_length=200,
    ) = Field(
        ...,
        description='The The Amazon Resource Name (ARN) of the code signing configuration.',
    )


class Field20210720FunctionsFunctionNameRuntimeManagementConfigPutRequest(BaseModel):
    RuntimeVersionArn: Optional[
        constr(
            pattern=r'^arn:(aws[a-zA-Z-]*):lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\d{1}::runtime:.+$',
            min_length=26,
            max_length=2048,
        )
    ] = Field(
        None,
        description="<p>The ARN of the runtime version you want the function to use.</p> <note> <p>This is only required if you're using the <b>Manual</b> runtime update mode.</p> </note>",
    )
    UpdateRuntimeOn_1: UpdateRuntimeOn = Field(
        ...,
        alias='UpdateRuntimeOn',
        description='<p>Specify the runtime update mode.</p> <ul> <li> <p> <b>Auto (default)</b> - Automatically update to the most recent and secure runtime version using a <a href="https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-two-phase">Two-phase runtime version rollout</a>. This is the best choice for most customers to ensure they always benefit from runtime updates.</p> </li> <li> <p> <b>Function update</b> - Lambda updates the runtime of your function to the most recent and secure runtime version when you update your function. This approach synchronizes runtime updates with function deployments, giving you control over when runtime updates are applied and allowing you to detect and mitigate rare runtime update incompatibilities early. When using this setting, you need to regularly update your functions to keep their runtime up-to-date.</p> </li> <li> <p> <b>Manual</b> - You specify a runtime version in your function configuration. The function will use this runtime version indefinitely. In the rare case where a new runtime version is incompatible with an existing function, this allows you to roll back your function to an earlier runtime version. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-rollback">Roll back a runtime version</a>.</p> </li> </ul>',
    )


class AuthType(Enum):
    NONE = 'NONE'
    AWS_IAM = 'AWS_IAM'


class Field20211115FunctionsFunctionNameResponseStreamingInvocationsPostRequest(
    BaseModel
):
    Payload: Optional[SecretStr] = Field(
        None,
        description='<p>The JSON that you want to provide to your Lambda function as input.</p> <p>You can enter the JSON directly. For example, <code>--payload \'{ "key": "value" }\'</code>. You can also specify a file path. For example, <code>--payload file://payload.json</code>.</p>',
    )


class XAmzInvocationType1(Enum):
    RequestResponse = 'RequestResponse'
    DryRun = 'DryRun'


class AccountLimit(BaseModel):
    CodeSizeUnzipped: Optional[Long] = None
    CodeSizeZipped: Optional[Long] = None
    ConcurrentExecutions: Optional[Integer] = None
    TotalCodeSize: Optional[Long] = None
    UnreservedConcurrentExecutions_1: Optional[UnreservedConcurrentExecutions] = Field(
        None, alias='UnreservedConcurrentExecutions'
    )


class AccountUsage(BaseModel):
    FunctionCount: Optional[Long] = None
    TotalCodeSize: Optional[Long] = None


class AddLayerVersionPermissionRequest(BaseModel):
    Action: LayerPermissionAllowedAction
    OrganizationId_1: Optional[OrganizationId] = Field(None, alias='OrganizationId')
    Principal: LayerPermissionAllowedPrincipal
    StatementId_1: StatementId = Field(..., alias='StatementId')


class AddLayerVersionPermissionResponse(BaseModel):
    RevisionId: Optional[String] = None
    Statement: Optional[String] = None


class AddPermissionRequest(BaseModel):
    Action_1: Action = Field(..., alias='Action')
    EventSourceToken_1: Optional[EventSourceToken] = Field(
        None, alias='EventSourceToken'
    )
    FunctionUrlAuthType_1: Optional[FunctionUrlAuthType] = Field(
        None, alias='FunctionUrlAuthType'
    )
    Principal_1: Principal = Field(..., alias='Principal')
    PrincipalOrgID_1: Optional[PrincipalOrgID] = Field(None, alias='PrincipalOrgID')
    RevisionId: Optional[String] = None
    SourceAccount: Optional[SourceOwner] = None
    SourceArn: Optional[Arn] = None
    StatementId_1: StatementId = Field(..., alias='StatementId')


class AddPermissionResponse(BaseModel):
    Statement: Optional[String] = None


class AdditionalVersionWeights(RootModel[Optional[Dict[str, Weight]]]):
    root: Optional[Dict[str, Weight]] = None


class AliasRoutingConfiguration(BaseModel):
    AdditionalVersionWeights_1: Optional[AdditionalVersionWeights] = Field(
        None, alias='AdditionalVersionWeights'
    )


class AllowMethodsList(RootModel[List[Method]]):
    root: List[Method] = Field(..., max_length=6)


class AllowOriginsList(RootModel[List[Origin]]):
    root: List[Origin] = Field(..., max_length=100)


class AllowedPublishers(BaseModel):
    SigningProfileVersionArns_1: SigningProfileVersionArns = Field(
        ..., alias='SigningProfileVersionArns'
    )


class CompatibleRuntimes(RootModel[List[Runtime]]):
    root: List[Runtime] = Field(..., max_length=15)


class Concurrency(BaseModel):
    ReservedConcurrentExecutions_1: Optional[ReservedConcurrentExecutions] = Field(
        None, alias='ReservedConcurrentExecutions'
    )


class Cors(BaseModel):
    AllowCredentials_1: Optional[AllowCredentials] = Field(
        None, alias='AllowCredentials'
    )
    AllowHeaders: Optional[HeadersList] = None
    AllowMethods: Optional[AllowMethodsList] = None
    AllowOrigins: Optional[AllowOriginsList] = None
    ExposeHeaders: Optional[HeadersList] = None
    MaxAge_1: Optional[MaxAge] = Field(None, alias='MaxAge')


class CreateAliasRequest(BaseModel):
    Description_1: Optional[Description] = Field(None, alias='Description')
    FunctionVersion: Version
    Name: Alias
    RoutingConfig: Optional[AliasRoutingConfiguration] = None


class CreateCodeSigningConfigRequest(BaseModel):
    AllowedPublishers_1: AllowedPublishers = Field(..., alias='AllowedPublishers')
    CodeSigningPolicies_1: Optional[CodeSigningPolicies] = Field(
        None, alias='CodeSigningPolicies'
    )
    Description_1: Optional[Description] = Field(None, alias='Description')


class CreateFunctionUrlConfigRequest(BaseModel):
    AuthType: FunctionUrlAuthType
    Cors_1: Optional[Cors] = Field(None, alias='Cors')
    InvokeMode_1: Optional[InvokeMode] = Field(None, alias='InvokeMode')


class CreateFunctionUrlConfigResponse(BaseModel):
    AuthType: FunctionUrlAuthType
    Cors_1: Optional[Cors] = Field(None, alias='Cors')
    CreationTime: Timestamp
    FunctionArn_1: FunctionArn = Field(..., alias='FunctionArn')
    FunctionUrl_1: FunctionUrl = Field(..., alias='FunctionUrl')
    InvokeMode_1: Optional[InvokeMode] = Field(None, alias='InvokeMode')


class EnvironmentError(BaseModel):
    ErrorCode: Optional[String] = None
    Message: Optional[SensitiveString] = None


class EnvironmentResponse(BaseModel):
    Error: Optional[EnvironmentError] = None
    Variables: Optional[EnvironmentVariables] = None


class EphemeralStorage(BaseModel):
    Size: EphemeralStorageSize


class FileSystemConfig(BaseModel):
    Arn: FileSystemArn
    LocalMountPath_1: LocalMountPath = Field(..., alias='LocalMountPath')


class FileSystemConfigList(RootModel[List[FileSystemConfig]]):
    root: List[FileSystemConfig] = Field(..., max_length=1)


class Filter(BaseModel):
    Pattern_1: Optional[Pattern] = Field(None, alias='Pattern')


class FilterList(RootModel[List[Filter]]):
    root: List[Filter]


class FunctionCode(BaseModel):
    ImageUri: Optional[String] = None
    S3Bucket_1: Optional[S3Bucket] = Field(None, alias='S3Bucket')
    S3Key_1: Optional[S3Key] = Field(None, alias='S3Key')
    S3ObjectVersion_1: Optional[S3ObjectVersion] = Field(None, alias='S3ObjectVersion')
    ZipFile: Optional[Blob] = None


class FunctionCodeLocation(BaseModel):
    ImageUri: Optional[String] = None
    Location: Optional[String] = None
    RepositoryType: Optional[String] = None
    ResolvedImageUri: Optional[String] = None


class FunctionEventInvokeConfig(BaseModel):
    DestinationConfig_1: Optional[DestinationConfig] = Field(
        None, alias='DestinationConfig'
    )
    FunctionArn_1: Optional[FunctionArn] = Field(None, alias='FunctionArn')
    LastModified: Optional[Date] = None
    MaximumEventAgeInSeconds_1: Optional[MaximumEventAgeInSeconds] = Field(
        None, alias='MaximumEventAgeInSeconds'
    )
    MaximumRetryAttempts_1: Optional[MaximumRetryAttempts] = Field(
        None, alias='MaximumRetryAttempts'
    )


class FunctionEventInvokeConfigList(RootModel[List[FunctionEventInvokeConfig]]):
    root: List[FunctionEventInvokeConfig]


class FunctionUrlConfig(BaseModel):
    AuthType: FunctionUrlAuthType
    Cors_1: Optional[Cors] = Field(None, alias='Cors')
    CreationTime: Timestamp
    FunctionArn_1: FunctionArn = Field(..., alias='FunctionArn')
    FunctionUrl_1: FunctionUrl = Field(..., alias='FunctionUrl')
    InvokeMode_1: Optional[InvokeMode] = Field(None, alias='InvokeMode')
    LastModifiedTime: Timestamp


class FunctionUrlConfigList(RootModel[List[FunctionUrlConfig]]):
    root: List[FunctionUrlConfig]


class GetAccountSettingsResponse(BaseModel):
    AccountLimit_1: Optional[AccountLimit] = Field(None, alias='AccountLimit')
    AccountUsage_1: Optional[AccountUsage] = Field(None, alias='AccountUsage')


class GetFunctionConcurrencyResponse(BaseModel):
    ReservedConcurrentExecutions_1: Optional[ReservedConcurrentExecutions] = Field(
        None, alias='ReservedConcurrentExecutions'
    )


class GetFunctionUrlConfigResponse(BaseModel):
    AuthType: FunctionUrlAuthType
    Cors_1: Optional[Cors] = Field(None, alias='Cors')
    CreationTime: Timestamp
    FunctionArn_1: FunctionArn = Field(..., alias='FunctionArn')
    FunctionUrl_1: FunctionUrl = Field(..., alias='FunctionUrl')
    InvokeMode_1: Optional[InvokeMode] = Field(None, alias='InvokeMode')
    LastModifiedTime: Timestamp


class GetLayerVersionPolicyResponse(BaseModel):
    Policy: Optional[String] = None
    RevisionId: Optional[String] = None


class GetPolicyResponse(BaseModel):
    Policy: Optional[String] = None
    RevisionId: Optional[String] = None


class GetProvisionedConcurrencyConfigResponse(BaseModel):
    AllocatedProvisionedConcurrentExecutions: Optional[NonNegativeInteger] = None
    AvailableProvisionedConcurrentExecutions: Optional[NonNegativeInteger] = None
    LastModified: Optional[Timestamp] = None
    RequestedProvisionedConcurrentExecutions: Optional[PositiveInteger] = None
    Status: Optional[ProvisionedConcurrencyStatusEnum] = None
    StatusReason: Optional[String] = None


class GetRuntimeManagementConfigResponse(BaseModel):
    FunctionArn: Optional[NameSpacedFunctionArn] = None
    RuntimeVersionArn_1: Optional[RuntimeVersionArn] = Field(
        None, alias='RuntimeVersionArn'
    )
    UpdateRuntimeOn_1: Optional[UpdateRuntimeOn] = Field(None, alias='UpdateRuntimeOn')


class ImageConfigError(BaseModel):
    ErrorCode: Optional[String] = None
    Message: Optional[SensitiveString] = None


class ImageConfigResponse(BaseModel):
    Error: Optional[ImageConfigError] = None
    ImageConfig_1: Optional[ImageConfig] = Field(None, alias='ImageConfig')


class InvokeWithResponseStreamCompleteEvent(BaseModel):
    ErrorCode: Optional[String] = None
    ErrorDetails: Optional[String] = None
    LogResult: Optional[String] = None


class InvokeWithResponseStreamResponseEvent(BaseModel):
    InvokeComplete: Optional[InvokeWithResponseStreamCompleteEvent] = None
    PayloadChunk: Optional[InvokeResponseStreamUpdate] = None


class Layer(BaseModel):
    Arn: Optional[LayerVersionArn] = None
    CodeSize: Optional[Long] = None
    SigningJobArn: Optional[Arn] = None
    SigningProfileVersionArn: Optional[Arn] = None


class LayerList(RootModel[List[LayerVersionArn]]):
    root: List[LayerVersionArn]


class LayerVersionContentInput(BaseModel):
    S3Bucket_1: Optional[S3Bucket] = Field(None, alias='S3Bucket')
    S3Key_1: Optional[S3Key] = Field(None, alias='S3Key')
    S3ObjectVersion_1: Optional[S3ObjectVersion] = Field(None, alias='S3ObjectVersion')
    ZipFile: Optional[Blob] = None


class LayerVersionContentOutput(BaseModel):
    CodeSha256: Optional[String] = None
    CodeSize: Optional[Long] = None
    Location: Optional[String] = None
    SigningJobArn: Optional[String] = None
    SigningProfileVersionArn: Optional[String] = None


class LayerVersionsListItem(BaseModel):
    CompatibleArchitectures_1: Optional[CompatibleArchitectures] = Field(
        None, alias='CompatibleArchitectures'
    )
    CompatibleRuntimes_1: Optional[CompatibleRuntimes] = Field(
        None, alias='CompatibleRuntimes'
    )
    CreatedDate: Optional[Timestamp] = None
    Description_1: Optional[Description] = Field(None, alias='Description')
    LayerVersionArn_1: Optional[LayerVersionArn] = Field(None, alias='LayerVersionArn')
    LicenseInfo_1: Optional[LicenseInfo] = Field(None, alias='LicenseInfo')
    Version: Optional[LayerVersionNumber] = None


class LayersListItem(BaseModel):
    LatestMatchingVersion: Optional[LayerVersionsListItem] = None
    LayerArn_1: Optional[LayerArn] = Field(None, alias='LayerArn')
    LayerName_1: Optional[LayerName] = Field(None, alias='LayerName')


class LayersReferenceList(RootModel[List[Layer]]):
    root: List[Layer]


class ListFunctionEventInvokeConfigsResponse(BaseModel):
    FunctionEventInvokeConfigs: Optional[FunctionEventInvokeConfigList] = None
    NextMarker: Optional[String] = None


class ListFunctionUrlConfigsResponse(BaseModel):
    FunctionUrlConfigs: FunctionUrlConfigList
    NextMarker: Optional[String] = None


class ListFunctionsByCodeSigningConfigResponse(BaseModel):
    FunctionArns: Optional[FunctionArnList] = None
    NextMarker: Optional[String] = None


class ListTagsResponse(BaseModel):
    Tags_1: Optional[Tags] = Field(None, alias='Tags')


class ProvisionedConcurrencyConfigListItem(BaseModel):
    AllocatedProvisionedConcurrentExecutions: Optional[NonNegativeInteger] = None
    AvailableProvisionedConcurrentExecutions: Optional[NonNegativeInteger] = None
    FunctionArn_1: Optional[FunctionArn] = Field(None, alias='FunctionArn')
    LastModified: Optional[Timestamp] = None
    RequestedProvisionedConcurrentExecutions: Optional[PositiveInteger] = None
    Status: Optional[ProvisionedConcurrencyStatusEnum] = None
    StatusReason: Optional[String] = None


class PublishLayerVersionRequest(BaseModel):
    CompatibleArchitectures_1: Optional[CompatibleArchitectures] = Field(
        None, alias='CompatibleArchitectures'
    )
    CompatibleRuntimes_1: Optional[CompatibleRuntimes] = Field(
        None, alias='CompatibleRuntimes'
    )
    Content: LayerVersionContentInput
    Description_1: Optional[Description] = Field(None, alias='Description')
    LicenseInfo_1: Optional[LicenseInfo] = Field(None, alias='LicenseInfo')


class PublishLayerVersionResponse(BaseModel):
    CompatibleArchitectures_1: Optional[CompatibleArchitectures] = Field(
        None, alias='CompatibleArchitectures'
    )
    CompatibleRuntimes_1: Optional[CompatibleRuntimes] = Field(
        None, alias='CompatibleRuntimes'
    )
    Content: Optional[LayerVersionContentOutput] = None
    CreatedDate: Optional[Timestamp] = None
    Description_1: Optional[Description] = Field(None, alias='Description')
    LayerArn_1: Optional[LayerArn] = Field(None, alias='LayerArn')
    LayerVersionArn_1: Optional[LayerVersionArn] = Field(None, alias='LayerVersionArn')
    LicenseInfo_1: Optional[LicenseInfo] = Field(None, alias='LicenseInfo')
    Version: Optional[LayerVersionNumber] = None


class PublishVersionRequest(BaseModel):
    CodeSha256: Optional[String] = None
    Description_1: Optional[Description] = Field(None, alias='Description')
    RevisionId: Optional[String] = None


class PutFunctionConcurrencyRequest(BaseModel):
    ReservedConcurrentExecutions_1: ReservedConcurrentExecutions = Field(
        ..., alias='ReservedConcurrentExecutions'
    )


class PutFunctionEventInvokeConfigRequest(BaseModel):
    DestinationConfig_1: Optional[DestinationConfig] = Field(
        None, alias='DestinationConfig'
    )
    MaximumEventAgeInSeconds_1: Optional[MaximumEventAgeInSeconds] = Field(
        None, alias='MaximumEventAgeInSeconds'
    )
    MaximumRetryAttempts_1: Optional[MaximumRetryAttempts] = Field(
        None, alias='MaximumRetryAttempts'
    )


class PutProvisionedConcurrencyConfigResponse(BaseModel):
    AllocatedProvisionedConcurrentExecutions: Optional[NonNegativeInteger] = None
    AvailableProvisionedConcurrentExecutions: Optional[NonNegativeInteger] = None
    LastModified: Optional[Timestamp] = None
    RequestedProvisionedConcurrentExecutions: Optional[PositiveInteger] = None
    Status: Optional[ProvisionedConcurrencyStatusEnum] = None
    StatusReason: Optional[String] = None


class PutRuntimeManagementConfigRequest(BaseModel):
    RuntimeVersionArn_1: Optional[RuntimeVersionArn] = Field(
        None, alias='RuntimeVersionArn'
    )
    UpdateRuntimeOn_1: UpdateRuntimeOn = Field(..., alias='UpdateRuntimeOn')


class PutRuntimeManagementConfigResponse(BaseModel):
    FunctionArn_1: FunctionArn = Field(..., alias='FunctionArn')
    RuntimeVersionArn_1: Optional[RuntimeVersionArn] = Field(
        None, alias='RuntimeVersionArn'
    )
    UpdateRuntimeOn_1: UpdateRuntimeOn = Field(..., alias='UpdateRuntimeOn')


class RuntimeVersionError(BaseModel):
    ErrorCode: Optional[String] = None
    Message: Optional[SensitiveString] = None


class SourceAccessConfiguration(BaseModel):
    Type: Optional[SourceAccessType] = None
    URI_1: Optional[URI] = Field(None, alias='URI')


class SourceAccessConfigurations(RootModel[List[SourceAccessConfiguration]]):
    root: List[SourceAccessConfiguration] = Field(..., max_length=22, min_length=0)


class TagResourceRequest(BaseModel):
    Tags_1: Tags = Field(..., alias='Tags')


class TracingConfigResponse(BaseModel):
    Mode: Optional[TracingMode] = None


class UpdateAliasRequest(BaseModel):
    Description_1: Optional[Description] = Field(None, alias='Description')
    FunctionVersion: Optional[Version] = None
    RevisionId: Optional[String] = None
    RoutingConfig: Optional[AliasRoutingConfiguration] = None


class UpdateCodeSigningConfigRequest(BaseModel):
    AllowedPublishers_1: Optional[AllowedPublishers] = Field(
        None, alias='AllowedPublishers'
    )
    CodeSigningPolicies_1: Optional[CodeSigningPolicies] = Field(
        None, alias='CodeSigningPolicies'
    )
    Description_1: Optional[Description] = Field(None, alias='Description')


class UpdateFunctionConfigurationRequest(BaseModel):
    DeadLetterConfig_1: Optional[DeadLetterConfig] = Field(
        None, alias='DeadLetterConfig'
    )
    Description_1: Optional[Description] = Field(None, alias='Description')
    Environment_1: Optional[Environment] = Field(None, alias='Environment')
    EphemeralStorage_1: Optional[EphemeralStorage] = Field(
        None, alias='EphemeralStorage'
    )
    FileSystemConfigs: Optional[FileSystemConfigList] = None
    Handler_1: Optional[Handler] = Field(None, alias='Handler')
    ImageConfig_1: Optional[ImageConfig] = Field(None, alias='ImageConfig')
    KMSKeyArn_1: Optional[KMSKeyArn] = Field(None, alias='KMSKeyArn')
    Layers: Optional[LayerList] = None
    MemorySize_1: Optional[MemorySize] = Field(None, alias='MemorySize')
    RevisionId: Optional[String] = None
    Role: Optional[RoleArn] = None
    Runtime_1: Optional[Runtime] = Field(None, alias='Runtime')
    SnapStart_1: Optional[SnapStart] = Field(None, alias='SnapStart')
    Timeout_1: Optional[Timeout] = Field(None, alias='Timeout')
    TracingConfig_1: Optional[TracingConfig] = Field(None, alias='TracingConfig')
    VpcConfig_1: Optional[VpcConfig] = Field(None, alias='VpcConfig')


class UpdateFunctionEventInvokeConfigRequest(BaseModel):
    DestinationConfig_1: Optional[DestinationConfig] = Field(
        None, alias='DestinationConfig'
    )
    MaximumEventAgeInSeconds_1: Optional[MaximumEventAgeInSeconds] = Field(
        None, alias='MaximumEventAgeInSeconds'
    )
    MaximumRetryAttempts_1: Optional[MaximumRetryAttempts] = Field(
        None, alias='MaximumRetryAttempts'
    )


class UpdateFunctionUrlConfigRequest(BaseModel):
    AuthType: Optional[FunctionUrlAuthType] = None
    Cors_1: Optional[Cors] = Field(None, alias='Cors')
    InvokeMode_1: Optional[InvokeMode] = Field(None, alias='InvokeMode')


class UpdateFunctionUrlConfigResponse(BaseModel):
    AuthType: FunctionUrlAuthType
    Cors_1: Optional[Cors] = Field(None, alias='Cors')
    CreationTime: Timestamp
    FunctionArn_1: FunctionArn = Field(..., alias='FunctionArn')
    FunctionUrl_1: FunctionUrl = Field(..., alias='FunctionUrl')
    InvokeMode_1: Optional[InvokeMode] = Field(None, alias='InvokeMode')
    LastModifiedTime: Timestamp


class VpcConfigResponse(BaseModel):
    SecurityGroupIds_1: Optional[SecurityGroupIds] = Field(
        None, alias='SecurityGroupIds'
    )
    SubnetIds_1: Optional[SubnetIds] = Field(None, alias='SubnetIds')
    VpcId_1: Optional[VpcId] = Field(None, alias='VpcId')


class FilterCriteria(BaseModel):
    Filters: Optional[FilterList] = None


class Field20150331EventSourceMappingsPostRequest(BaseModel):
    AmazonManagedKafkaEventSourceConfig_1: Optional[
        AmazonManagedKafkaEventSourceConfig
    ] = Field(
        None,
        alias='AmazonManagedKafkaEventSourceConfig',
        description='Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.',
    )
    BatchSize: Optional[conint(ge=1, le=10000)] = Field(
        None,
        description='<p>The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB).</p> <ul> <li> <p> <b>Amazon Kinesis</b>  Default 100. Max 10,000.</p> </li> <li> <p> <b>Amazon DynamoDB Streams</b>  Default 100. Max 10,000.</p> </li> <li> <p> <b>Amazon Simple Queue Service</b>  Default 10. For standard queues the max is 10,000. For FIFO queues the max is 10.</p> </li> <li> <p> <b>Amazon Managed Streaming for Apache Kafka</b>  Default 100. Max 10,000.</p> </li> <li> <p> <b>Self-managed Apache Kafka</b>  Default 100. Max 10,000.</p> </li> <li> <p> <b>Amazon MQ (ActiveMQ and RabbitMQ)</b>  Default 100. Max 10,000.</p> </li> <li> <p> <b>DocumentDB</b>  Default 100. Max 10,000.</p> </li> </ul>',
    )
    BisectBatchOnFunctionError: Optional[bool] = Field(
        None,
        description='(Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and retry.',
    )
    DestinationConfig_1: Optional[DestinationConfig] = Field(
        None,
        alias='DestinationConfig',
        description='A configuration object that specifies the destination of an event after Lambda processes it.',
    )
    DocumentDBEventSourceConfig_1: Optional[DocumentDBEventSourceConfig] = Field(
        None,
        alias='DocumentDBEventSourceConfig',
        description=' Specific configuration settings for a DocumentDB event source. ',
    )
    Enabled: Optional[bool] = Field(
        None,
        description='<p>When true, the event source mapping is active. When false, Lambda pauses polling and invocation.</p> <p>Default: True</p>',
    )
    EventSourceArn: Optional[
        constr(
            pattern=r'arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)'
        )
    ] = Field(
        None,
        description='<p>The Amazon Resource Name (ARN) of the event source.</p> <ul> <li> <p> <b>Amazon Kinesis</b>  The ARN of the data stream or a stream consumer.</p> </li> <li> <p> <b>Amazon DynamoDB Streams</b>  The ARN of the stream.</p> </li> <li> <p> <b>Amazon Simple Queue Service</b>  The ARN of the queue.</p> </li> <li> <p> <b>Amazon Managed Streaming for Apache Kafka</b>  The ARN of the cluster.</p> </li> <li> <p> <b>Amazon MQ</b>  The ARN of the broker.</p> </li> <li> <p> <b>Amazon DocumentDB</b>  The ARN of the DocumentDB change stream.</p> </li> </ul>',
    )
    FilterCriteria_1: Optional[FilterCriteria] = Field(
        None,
        alias='FilterCriteria',
        description=' An object that contains the filters for an event source. ',
    )
    FunctionName: constr(
        pattern=r'(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?',
        min_length=1,
        max_length=140,
    ) = Field(
        ...,
        description='<p>The name of the Lambda function.</p> <p class="title"> <b>Name formats</b> </p> <ul> <li> <p> <b>Function name</b>  <code>MyFunction</code>.</p> </li> <li> <p> <b>Function ARN</b>  <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p> </li> <li> <p> <b>Version or Alias ARN</b>  <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD</code>.</p> </li> <li> <p> <b>Partial ARN</b>  <code>123456789012:function:MyFunction</code>.</p> </li> </ul> <p>The length constraint applies only to the full ARN. If you specify only the function name, it\'s limited to 64 characters in length.</p>',
    )
    FunctionResponseTypes: Optional[List[FunctionResponseType]] = Field(
        None,
        description='(Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the event source mapping.',
        max_length=1,
        min_length=0,
    )
    MaximumBatchingWindowInSeconds: Optional[conint(ge=0, le=300)] = Field(
        None,
        description='<p>The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure <code>MaximumBatchingWindowInSeconds</code> to any value from 0 seconds to 300 seconds in increments of seconds.</p> <p>For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change <code>MaximumBatchingWindowInSeconds</code> in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping.</p> <p>Related setting: For streams and Amazon SQS event sources, when you set <code>BatchSize</code> to a value greater than 10, you must set <code>MaximumBatchingWindowInSeconds</code> to at least 1.</p>',
    )
    MaximumRecordAgeInSeconds: Optional[conint(ge=-1, le=604800)] = Field(
        None,
        description='(Kinesis and DynamoDB Streams only) Discard records older than the specified age. The default value is infinite (-1).',
    )
    MaximumRetryAttempts: Optional[conint(ge=-1, le=10000)] = Field(
        None,
        description='(Kinesis and DynamoDB Streams only) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.',
    )
    ParallelizationFactor: Optional[conint(ge=1, le=10)] = Field(
        None,
        description='(Kinesis and DynamoDB Streams only) The number of batches to process from each shard concurrently.',
    )
    Queues: Optional[List[Queue]] = Field(
        None,
        description=' (MQ) The name of the Amazon MQ broker destination queue to consume. ',
        max_length=1,
        min_length=1,
    )
    ScalingConfig_1: Optional[ScalingConfig] = Field(
        None,
        alias='ScalingConfig',
        description='(Amazon SQS only) The scaling configuration for the event source. To remove the configuration, pass an empty value.',
    )
    SelfManagedEventSource_1: Optional[SelfManagedEventSource] = Field(
        None,
        alias='SelfManagedEventSource',
        description='The self-managed Apache Kafka cluster for your event source.',
    )
    SelfManagedKafkaEventSourceConfig_1: Optional[SelfManagedKafkaEventSourceConfig] = (
        Field(
            None,
            alias='SelfManagedKafkaEventSourceConfig',
            description='Specific configuration settings for a self-managed Apache Kafka event source.',
        )
    )
    SourceAccessConfigurations: Optional[List[SourceAccessConfiguration]] = Field(
        None,
        description='An array of authentication protocols or VPC components required to secure your event source.',
        max_length=22,
        min_length=0,
    )
    StartingPosition_1: Optional[StartingPosition] = Field(
        None,
        alias='StartingPosition',
        description='The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK Streams sources. <code>AT_TIMESTAMP</code> is supported only for Amazon Kinesis streams and Amazon DocumentDB.',
    )
    StartingPositionTimestamp: Optional[datetime] = Field(
        None,
        description='With <code>StartingPosition</code> set to <code>AT_TIMESTAMP</code>, the time from which to start reading.',
    )
    Topics: Optional[List[Topic]] = Field(
        None, description='The name of the Kafka topic.', max_length=1, min_length=1
    )
    TumblingWindowInSeconds: Optional[conint(ge=0, le=900)] = Field(
        None,
        description='(Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.',
    )


class Field20150331EventSourceMappingsUUIDPutRequest(BaseModel):
    BatchSize: Optional[conint(ge=1, le=10000)] = Field(
        None,
        description='<p>The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB).</p> <ul> <li> <p> <b>Amazon Kinesis</b>  Default 100. Max 10,000.</p> </li> <li> <p> <b>Amazon DynamoDB Streams</b>  Default 100. Max 10,000.</p> </li> <li> <p> <b>Amazon Simple Queue Service</b>  Default 10. For standard queues the max is 10,000. For FIFO queues the max is 10.</p> </li> <li> <p> <b>Amazon Managed Streaming for Apache Kafka</b>  Default 100. Max 10,000.</p> </li> <li> <p> <b>Self-managed Apache Kafka</b>  Default 100. Max 10,000.</p> </li> <li> <p> <b>Amazon MQ (ActiveMQ and RabbitMQ)</b>  Default 100. Max 10,000.</p> </li> <li> <p> <b>DocumentDB</b>  Default 100. Max 10,000.</p> </li> </ul>',
    )
    BisectBatchOnFunctionError: Optional[bool] = Field(
        None,
        description='(Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and retry.',
    )
    DestinationConfig_1: Optional[DestinationConfig] = Field(
        None,
        alias='DestinationConfig',
        description='A configuration object that specifies the destination of an event after Lambda processes it.',
    )
    DocumentDBEventSourceConfig_1: Optional[DocumentDBEventSourceConfig] = Field(
        None,
        alias='DocumentDBEventSourceConfig',
        description=' Specific configuration settings for a DocumentDB event source. ',
    )
    Enabled: Optional[bool] = Field(
        None,
        description='<p>When true, the event source mapping is active. When false, Lambda pauses polling and invocation.</p> <p>Default: True</p>',
    )
    FilterCriteria_1: Optional[FilterCriteria] = Field(
        None,
        alias='FilterCriteria',
        description=' An object that contains the filters for an event source. ',
    )
    FunctionName: Optional[
        constr(
            pattern=r'(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?',
            min_length=1,
            max_length=140,
        )
    ] = Field(
        None,
        description='<p>The name of the Lambda function.</p> <p class="title"> <b>Name formats</b> </p> <ul> <li> <p> <b>Function name</b>  <code>MyFunction</code>.</p> </li> <li> <p> <b>Function ARN</b>  <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p> </li> <li> <p> <b>Version or Alias ARN</b>  <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD</code>.</p> </li> <li> <p> <b>Partial ARN</b>  <code>123456789012:function:MyFunction</code>.</p> </li> </ul> <p>The length constraint applies only to the full ARN. If you specify only the function name, it\'s limited to 64 characters in length.</p>',
    )
    FunctionResponseTypes: Optional[List[FunctionResponseType]] = Field(
        None,
        description='(Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the event source mapping.',
        max_length=1,
        min_length=0,
    )
    MaximumBatchingWindowInSeconds: Optional[conint(ge=0, le=300)] = Field(
        None,
        description='<p>The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure <code>MaximumBatchingWindowInSeconds</code> to any value from 0 seconds to 300 seconds in increments of seconds.</p> <p>For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change <code>MaximumBatchingWindowInSeconds</code> in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping.</p> <p>Related setting: For streams and Amazon SQS event sources, when you set <code>BatchSize</code> to a value greater than 10, you must set <code>MaximumBatchingWindowInSeconds</code> to at least 1.</p>',
    )
    MaximumRecordAgeInSeconds: Optional[conint(ge=-1, le=604800)] = Field(
        None,
        description='(Kinesis and DynamoDB Streams only) Discard records older than the specified age. The default value is infinite (-1).',
    )
    MaximumRetryAttempts: Optional[conint(ge=-1, le=10000)] = Field(
        None,
        description='(Kinesis and DynamoDB Streams only) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.',
    )
    ParallelizationFactor: Optional[conint(ge=1, le=10)] = Field(
        None,
        description='(Kinesis and DynamoDB Streams only) The number of batches to process from each shard concurrently.',
    )
    ScalingConfig_1: Optional[ScalingConfig] = Field(
        None,
        alias='ScalingConfig',
        description='(Amazon SQS only) The scaling configuration for the event source. To remove the configuration, pass an empty value.',
    )
    SourceAccessConfigurations: Optional[List[SourceAccessConfiguration]] = Field(
        None,
        description='An array of authentication protocols or VPC components required to secure your event source.',
        max_length=22,
        min_length=0,
    )
    TumblingWindowInSeconds: Optional[conint(ge=0, le=900)] = Field(
        None,
        description='(Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.',
    )


class Field20150331FunctionsPostRequest(BaseModel):
    Architectures: Optional[List[Architecture]] = Field(
        None,
        description='The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64). The default value is <code>x86_64</code>.',
        max_length=1,
        min_length=1,
    )
    Code_1: Code = Field(
        ...,
        alias='Code',
        description='The code for the Lambda function. You can either specify an object in Amazon S3, upload a .zip file archive deployment package directly, or specify the URI of a container image.',
    )
    CodeSigningConfigArn: Optional[
        constr(
            pattern=r'arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\d{1}:\d{12}:code-signing-config:csc-[a-z0-9]{17}',
            max_length=200,
        )
    ] = Field(
        None,
        description='To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration includes a set of signing profiles, which define the trusted publishers for this function.',
    )
    DeadLetterConfig_1: Optional[DeadLetterConfig] = Field(
        None,
        alias='DeadLetterConfig',
        description='The <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq">dead-letter queue</a> for failed asynchronous invocations.',
    )
    Description: Optional[constr(min_length=0, max_length=256)] = Field(
        None, description='A description of the function.'
    )
    Environment_1: Optional[Environment] = Field(
        None,
        alias='Environment',
        description="A function's environment variable settings. You can use environment variables to adjust your function's behavior without updating code. An environment variable is a pair of strings that are stored in a function's version-specific configuration.",
    )
    EphemeralStorage: Optional[EphemeralStorage1] = Field(
        None,
        description="The size of the function's <code>/tmp</code> directory in MB. The default value is 512, but it can be any whole number between 512 and 10,240 MB.",
    )
    FileSystemConfigs: Optional[List[FileSystemConfig]] = Field(
        None,
        description='Connection settings for an Amazon EFS file system.',
        max_length=1,
    )
    FunctionName: constr(
        pattern=r'(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?',
        min_length=1,
        max_length=140,
    ) = Field(
        ...,
        description='<p>The name of the Lambda function.</p> <p class="title"> <b>Name formats</b> </p> <ul> <li> <p> <b>Function name</b>  <code>my-function</code>.</p> </li> <li> <p> <b>Function ARN</b>  <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p> </li> <li> <p> <b>Partial ARN</b>  <code>123456789012:function:my-function</code>.</p> </li> </ul> <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.</p>',
    )
    Handler: Optional[constr(pattern=r'[^\s]+', max_length=128)] = Field(
        None,
        description='The name of the method within your code that Lambda calls to run your function. Handler is required if the deployment package is a .zip file archive. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/foundation-progmodel.html">Lambda programming model</a>.',
    )
    ImageConfig_1: Optional[ImageConfig] = Field(
        None,
        alias='ImageConfig',
        description='Configuration values that override the container image Dockerfile settings. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms">Container image settings</a>.',
    )
    KMSKeyArn: Optional[constr(pattern=r'(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()')] = (
        Field(
            None,
            description='The ARN of the Key Management Service (KMS) customer managed key that\'s used to encrypt your function\'s <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption">environment variables</a>. When <a href="https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html">Lambda SnapStart</a> is activated, this key is also used to encrypt your function\'s snapshot. If you don\'t provide a customer managed key, Lambda uses a default service key.',
        )
    )
    Layers: Optional[List[LayerVersionArn]] = Field(
        None,
        description='A list of <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">function layers</a> to add to the function\'s execution environment. Specify each layer by its ARN, including the version.',
    )
    MemorySize: Optional[conint(ge=128, le=10240)] = Field(
        None,
        description='The amount of <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-memory-console">memory available to the function</a> at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.',
    )
    PackageType_1: Optional[PackageType] = Field(
        None,
        alias='PackageType',
        description='The type of deployment package. Set to <code>Image</code> for container image and set to <code>Zip</code> for .zip file archive.',
    )
    Publish: Optional[bool] = Field(
        None,
        description='Set to true to publish the first version of the function during creation.',
    )
    Role: constr(
        pattern=r'arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+'
    ) = Field(
        ...,
        description="The Amazon Resource Name (ARN) of the function's execution role.",
    )
    Runtime_1: Optional[Runtime] = Field(
        None,
        alias='Runtime',
        description='<p>The identifier of the function\'s <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html">runtime</a>. Runtime is required if the deployment package is a .zip file archive.</p> <p>The following list includes deprecated runtimes. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy">Runtime deprecation policy</a>.</p>',
    )
    SnapStart_1: Optional[SnapStart] = Field(
        None,
        alias='SnapStart',
        description='<p>The function\'s Lambda SnapStart setting. Set <code>ApplyOn</code> to <code>PublishedVersions</code> to create a snapshot of the initialized execution environment when you publish a function version.</p> <p>SnapStart is supported with the <code>java11</code> runtime. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html">Improving startup performance with Lambda SnapStart</a>.</p>',
    )
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='A list of <a href="https://docs.aws.amazon.com/lambda/latest/dg/tagging.html">tags</a> to apply to the function.',
    )
    Timeout: Optional[conint(ge=1)] = Field(
        None,
        description='The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html">Lambda execution environment</a>.',
    )
    TracingConfig_1: Optional[TracingConfig] = Field(
        None,
        alias='TracingConfig',
        description='The function\'s <a href="https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html">X-Ray</a> tracing configuration. To sample and record incoming requests, set <code>Mode</code> to <code>Active</code>.',
    )
    VpcConfig_1: Optional[VpcConfig] = Field(
        None,
        alias='VpcConfig',
        description='The VPC security groups and subnets that are attached to a Lambda function. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html">Configuring a Lambda function to access resources in a VPC</a>.',
    )


class RoutingConfig(BaseModel):
    AdditionalVersionWeights_1: Optional[AdditionalVersionWeights] = Field(
        None, alias='AdditionalVersionWeights'
    )


class Field20150331FunctionsFunctionNameAliasesPostRequest(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    Description: Optional[constr(min_length=0, max_length=256)] = Field(
        None, description='A description of the alias.'
    )
    FunctionVersion: constr(
        pattern=r'(\$LATEST|[0-9]+)', min_length=1, max_length=1024
    ) = Field(..., description='The function version that the alias invokes.')
    Name: constr(
        pattern=r'(?!^[0-9]+$)([a-zA-Z0-9-_]+)', min_length=1, max_length=128
    ) = Field(..., description='The name of the alias.')
    RoutingConfig_1: Optional[RoutingConfig] = Field(
        None,
        alias='RoutingConfig',
        description='The <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html">traffic-shifting</a> configuration of a Lambda function alias.',
    )


class Field20150331FunctionsFunctionNameAliasesNamePutRequest(BaseModel):
    Description: Optional[constr(min_length=0, max_length=256)] = Field(
        None, description='A description of the alias.'
    )
    FunctionVersion: Optional[
        constr(pattern=r'(\$LATEST|[0-9]+)', min_length=1, max_length=1024)
    ] = Field(None, description='The function version that the alias invokes.')
    RevisionId: Optional[str] = Field(
        None,
        description="Only update the alias if the revision ID matches the ID that's specified. Use this option to avoid modifying an alias that has changed since you last read it.",
    )
    RoutingConfig_1: Optional[RoutingConfig] = Field(
        None,
        alias='RoutingConfig',
        description='The <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html">traffic-shifting</a> configuration of a Lambda function alias.',
    )


class Field20150331FunctionsFunctionNameConfigurationPutRequest(BaseModel):
    DeadLetterConfig_1: Optional[DeadLetterConfig] = Field(
        None,
        alias='DeadLetterConfig',
        description='The <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq">dead-letter queue</a> for failed asynchronous invocations.',
    )
    Description: Optional[constr(min_length=0, max_length=256)] = Field(
        None, description='A description of the function.'
    )
    Environment_1: Optional[Environment] = Field(
        None,
        alias='Environment',
        description="A function's environment variable settings. You can use environment variables to adjust your function's behavior without updating code. An environment variable is a pair of strings that are stored in a function's version-specific configuration.",
    )
    EphemeralStorage: Optional[EphemeralStorage1] = Field(
        None,
        description="The size of the function's <code>/tmp</code> directory in MB. The default value is 512, but it can be any whole number between 512 and 10,240 MB.",
    )
    FileSystemConfigs: Optional[List[FileSystemConfig]] = Field(
        None,
        description='Connection settings for an Amazon EFS file system.',
        max_length=1,
    )
    Handler: Optional[constr(pattern=r'[^\s]+', max_length=128)] = Field(
        None,
        description='The name of the method within your code that Lambda calls to run your function. Handler is required if the deployment package is a .zip file archive. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/foundation-progmodel.html">Lambda programming model</a>.',
    )
    ImageConfig_1: Optional[ImageConfig] = Field(
        None,
        alias='ImageConfig',
        description='Configuration values that override the container image Dockerfile settings. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms">Container image settings</a>.',
    )
    KMSKeyArn: Optional[constr(pattern=r'(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()')] = (
        Field(
            None,
            description='The ARN of the Key Management Service (KMS) customer managed key that\'s used to encrypt your function\'s <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption">environment variables</a>. When <a href="https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html">Lambda SnapStart</a> is activated, this key is also used to encrypt your function\'s snapshot. If you don\'t provide a customer managed key, Lambda uses a default service key.',
        )
    )
    Layers: Optional[List[LayerVersionArn]] = Field(
        None,
        description='A list of <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">function layers</a> to add to the function\'s execution environment. Specify each layer by its ARN, including the version.',
    )
    MemorySize: Optional[conint(ge=128, le=10240)] = Field(
        None,
        description='The amount of <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-memory-console">memory available to the function</a> at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.',
    )
    RevisionId: Optional[str] = Field(
        None,
        description="Update the function only if the revision ID matches the ID that's specified. Use this option to avoid modifying a function that has changed since you last read it.",
    )
    Role: Optional[
        constr(pattern=r'arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+')
    ] = Field(
        None,
        description="The Amazon Resource Name (ARN) of the function's execution role.",
    )
    Runtime_1: Optional[Runtime] = Field(
        None,
        alias='Runtime',
        description='<p>The identifier of the function\'s <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html">runtime</a>. Runtime is required if the deployment package is a .zip file archive.</p> <p>The following list includes deprecated runtimes. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy">Runtime deprecation policy</a>.</p>',
    )
    SnapStart_1: Optional[SnapStart] = Field(
        None,
        alias='SnapStart',
        description='<p>The function\'s Lambda SnapStart setting. Set <code>ApplyOn</code> to <code>PublishedVersions</code> to create a snapshot of the initialized execution environment when you publish a function version.</p> <p>SnapStart is supported with the <code>java11</code> runtime. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html">Improving startup performance with Lambda SnapStart</a>.</p>',
    )
    Timeout: Optional[conint(ge=1)] = Field(
        None,
        description='The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html">Lambda execution environment</a>.',
    )
    TracingConfig_1: Optional[TracingConfig] = Field(
        None,
        alias='TracingConfig',
        description='The function\'s <a href="https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html">X-Ray</a> tracing configuration. To sample and record incoming requests, set <code>Mode</code> to <code>Active</code>.',
    )
    VpcConfig_1: Optional[VpcConfig] = Field(
        None,
        alias='VpcConfig',
        description='The VPC security groups and subnets that are attached to a Lambda function. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html">Configuring a Lambda function to access resources in a VPC</a>.',
    )


class Field20211031FunctionsFunctionNameUrlPostRequest(BaseModel):
    AuthType_1: AuthType = Field(
        ...,
        alias='AuthType',
        description='The type of authentication that your function URL uses. Set to <code>AWS_IAM</code> if you want to restrict access to authenticated users only. Set to <code>NONE</code> if you want to bypass IAM authentication to create a public endpoint. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html">Security and auth model for Lambda function URLs</a>.',
    )
    Cors_1: Optional[Cors] = Field(
        None,
        alias='Cors',
        description='The <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">cross-origin resource sharing (CORS)</a> settings for your Lambda function URL. Use CORS to grant access to your function URL from any origin. You can also use CORS to control access for specific HTTP headers and methods in requests to your function URL.',
    )
    InvokeMode_1: Optional[InvokeMode] = Field(
        None,
        alias='InvokeMode',
        description='<p>Use one of the following options:</p> <ul> <li> <p> <code>BUFFERED</code>  This is the default option. Lambda invokes your function using the <code>Invoke</code> API operation. Invocation results are available when the payload is complete. The maximum payload size is 6 MB.</p> </li> <li> <p> <code>RESPONSE_STREAM</code>  Your function streams payload results as they become available. Lambda invokes your function using the <code>InvokeWithResponseStream</code> API operation. The maximum response payload size is 20 MB, however, you can <a href="https://docs.aws.amazon.com/servicequotas/latest/userguide/request-quota-increase.html">request a quota increase</a>.</p> </li> </ul>',
    )


class Field20211031FunctionsFunctionNameUrlPutRequest(BaseModel):
    AuthType_1: Optional[AuthType] = Field(
        None,
        alias='AuthType',
        description='The type of authentication that your function URL uses. Set to <code>AWS_IAM</code> if you want to restrict access to authenticated users only. Set to <code>NONE</code> if you want to bypass IAM authentication to create a public endpoint. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html">Security and auth model for Lambda function URLs</a>.',
    )
    Cors_1: Optional[Cors] = Field(
        None,
        alias='Cors',
        description='The <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">cross-origin resource sharing (CORS)</a> settings for your Lambda function URL. Use CORS to grant access to your function URL from any origin. You can also use CORS to control access for specific HTTP headers and methods in requests to your function URL.',
    )
    InvokeMode_1: Optional[InvokeMode] = Field(
        None,
        alias='InvokeMode',
        description='<p>Use one of the following options:</p> <ul> <li> <p> <code>BUFFERED</code>  This is the default option. Lambda invokes your function using the <code>Invoke</code> API operation. Invocation results are available when the payload is complete. The maximum payload size is 6 MB.</p> </li> <li> <p> <code>RESPONSE_STREAM</code>  Your function streams payload results as they become available. Lambda invokes your function using the <code>InvokeWithResponseStream</code> API operation. The maximum response payload size is 20 MB, however, you can <a href="https://docs.aws.amazon.com/servicequotas/latest/userguide/request-quota-increase.html">request a quota increase</a>.</p> </li> </ul>',
    )


class AliasConfiguration(BaseModel):
    AliasArn: Optional[FunctionArn] = None
    Description_1: Optional[Description] = Field(None, alias='Description')
    FunctionVersion: Optional[Version] = None
    Name: Optional[Alias] = None
    RevisionId: Optional[String] = None
    RoutingConfig: Optional[AliasRoutingConfiguration] = None


class AliasList(RootModel[List[AliasConfiguration]]):
    root: List[AliasConfiguration]


class CodeSigningConfig(BaseModel):
    AllowedPublishers_1: AllowedPublishers = Field(..., alias='AllowedPublishers')
    CodeSigningConfigArn_1: CodeSigningConfigArn = Field(
        ..., alias='CodeSigningConfigArn'
    )
    CodeSigningConfigId_1: CodeSigningConfigId = Field(..., alias='CodeSigningConfigId')
    CodeSigningPolicies_1: CodeSigningPolicies = Field(..., alias='CodeSigningPolicies')
    Description_1: Optional[Description] = Field(None, alias='Description')
    LastModified: Timestamp


class CodeSigningConfigList(RootModel[List[CodeSigningConfig]]):
    root: List[CodeSigningConfig]


class CreateCodeSigningConfigResponse(BaseModel):
    CodeSigningConfig_1: CodeSigningConfig = Field(..., alias='CodeSigningConfig')


class CreateFunctionRequest(BaseModel):
    Architectures: Optional[ArchitecturesList] = None
    Code: FunctionCode
    CodeSigningConfigArn_1: Optional[CodeSigningConfigArn] = Field(
        None, alias='CodeSigningConfigArn'
    )
    DeadLetterConfig_1: Optional[DeadLetterConfig] = Field(
        None, alias='DeadLetterConfig'
    )
    Description_1: Optional[Description] = Field(None, alias='Description')
    Environment_1: Optional[Environment] = Field(None, alias='Environment')
    EphemeralStorage_1: Optional[EphemeralStorage] = Field(
        None, alias='EphemeralStorage'
    )
    FileSystemConfigs: Optional[FileSystemConfigList] = None
    FunctionName_1: FunctionName = Field(..., alias='FunctionName')
    Handler_1: Optional[Handler] = Field(None, alias='Handler')
    ImageConfig_1: Optional[ImageConfig] = Field(None, alias='ImageConfig')
    KMSKeyArn_1: Optional[KMSKeyArn] = Field(None, alias='KMSKeyArn')
    Layers: Optional[LayerList] = None
    MemorySize_1: Optional[MemorySize] = Field(None, alias='MemorySize')
    PackageType_1: Optional[PackageType] = Field(None, alias='PackageType')
    Publish: Optional[Boolean] = None
    Role: RoleArn
    Runtime_1: Optional[Runtime] = Field(None, alias='Runtime')
    SnapStart_1: Optional[SnapStart] = Field(None, alias='SnapStart')
    Tags_1: Optional[Tags] = Field(None, alias='Tags')
    Timeout_1: Optional[Timeout] = Field(None, alias='Timeout')
    TracingConfig_1: Optional[TracingConfig] = Field(None, alias='TracingConfig')
    VpcConfig_1: Optional[VpcConfig] = Field(None, alias='VpcConfig')


class GetCodeSigningConfigResponse(BaseModel):
    CodeSigningConfig_1: CodeSigningConfig = Field(..., alias='CodeSigningConfig')


class GetLayerVersionResponse(BaseModel):
    CompatibleArchitectures_1: Optional[CompatibleArchitectures] = Field(
        None, alias='CompatibleArchitectures'
    )
    CompatibleRuntimes_1: Optional[CompatibleRuntimes] = Field(
        None, alias='CompatibleRuntimes'
    )
    Content: Optional[LayerVersionContentOutput] = None
    CreatedDate: Optional[Timestamp] = None
    Description_1: Optional[Description] = Field(None, alias='Description')
    LayerArn_1: Optional[LayerArn] = Field(None, alias='LayerArn')
    LayerVersionArn_1: Optional[LayerVersionArn] = Field(None, alias='LayerVersionArn')
    LicenseInfo_1: Optional[LicenseInfo] = Field(None, alias='LicenseInfo')
    Version: Optional[LayerVersionNumber] = None


class InvokeWithResponseStreamResponse(BaseModel):
    EventStream: Optional[InvokeWithResponseStreamResponseEvent] = None
    StatusCode: Optional[Integer] = None


class LayerVersionsList(RootModel[List[LayerVersionsListItem]]):
    root: List[LayerVersionsListItem]


class LayersList(RootModel[List[LayersListItem]]):
    root: List[LayersListItem]


class ListAliasesResponse(BaseModel):
    Aliases: Optional[AliasList] = None
    NextMarker: Optional[String] = None


class ListCodeSigningConfigsResponse(BaseModel):
    CodeSigningConfigs: Optional[CodeSigningConfigList] = None
    NextMarker: Optional[String] = None


class ListLayerVersionsResponse(BaseModel):
    LayerVersions: Optional[LayerVersionsList] = None
    NextMarker: Optional[String] = None


class ListLayersResponse(BaseModel):
    Layers: Optional[LayersList] = None
    NextMarker: Optional[String] = None


class ProvisionedConcurrencyConfigList(
    RootModel[List[ProvisionedConcurrencyConfigListItem]]
):
    root: List[ProvisionedConcurrencyConfigListItem]


class RuntimeVersionConfig(BaseModel):
    Error: Optional[RuntimeVersionError] = None
    RuntimeVersionArn_1: Optional[RuntimeVersionArn] = Field(
        None, alias='RuntimeVersionArn'
    )


class UpdateCodeSigningConfigResponse(BaseModel):
    CodeSigningConfig_1: CodeSigningConfig = Field(..., alias='CodeSigningConfig')


class UpdateEventSourceMappingRequest(BaseModel):
    BatchSize_1: Optional[BatchSize] = Field(None, alias='BatchSize')
    BisectBatchOnFunctionError_1: Optional[BisectBatchOnFunctionError] = Field(
        None, alias='BisectBatchOnFunctionError'
    )
    DestinationConfig_1: Optional[DestinationConfig] = Field(
        None, alias='DestinationConfig'
    )
    DocumentDBEventSourceConfig_1: Optional[DocumentDBEventSourceConfig] = Field(
        None, alias='DocumentDBEventSourceConfig'
    )
    Enabled_1: Optional[Enabled] = Field(None, alias='Enabled')
    FilterCriteria_1: Optional[FilterCriteria] = Field(None, alias='FilterCriteria')
    FunctionName_1: Optional[FunctionName] = Field(None, alias='FunctionName')
    FunctionResponseTypes: Optional[FunctionResponseTypeList] = None
    MaximumBatchingWindowInSeconds_1: Optional[MaximumBatchingWindowInSeconds] = Field(
        None, alias='MaximumBatchingWindowInSeconds'
    )
    MaximumRecordAgeInSeconds_1: Optional[MaximumRecordAgeInSeconds] = Field(
        None, alias='MaximumRecordAgeInSeconds'
    )
    MaximumRetryAttempts: Optional[MaximumRetryAttemptsEventSourceMapping] = None
    ParallelizationFactor_1: Optional[ParallelizationFactor] = Field(
        None, alias='ParallelizationFactor'
    )
    ScalingConfig_1: Optional[ScalingConfig] = Field(None, alias='ScalingConfig')
    SourceAccessConfigurations_1: Optional[SourceAccessConfigurations] = Field(
        None, alias='SourceAccessConfigurations'
    )
    TumblingWindowInSeconds_1: Optional[TumblingWindowInSeconds] = Field(
        None, alias='TumblingWindowInSeconds'
    )


class CreateEventSourceMappingRequest(BaseModel):
    AmazonManagedKafkaEventSourceConfig_1: Optional[
        AmazonManagedKafkaEventSourceConfig
    ] = Field(None, alias='AmazonManagedKafkaEventSourceConfig')
    BatchSize_1: Optional[BatchSize] = Field(None, alias='BatchSize')
    BisectBatchOnFunctionError_1: Optional[BisectBatchOnFunctionError] = Field(
        None, alias='BisectBatchOnFunctionError'
    )
    DestinationConfig_1: Optional[DestinationConfig] = Field(
        None, alias='DestinationConfig'
    )
    DocumentDBEventSourceConfig_1: Optional[DocumentDBEventSourceConfig] = Field(
        None, alias='DocumentDBEventSourceConfig'
    )
    Enabled_1: Optional[Enabled] = Field(None, alias='Enabled')
    EventSourceArn: Optional[Arn] = None
    FilterCriteria_1: Optional[FilterCriteria] = Field(None, alias='FilterCriteria')
    FunctionName_1: FunctionName = Field(..., alias='FunctionName')
    FunctionResponseTypes: Optional[FunctionResponseTypeList] = None
    MaximumBatchingWindowInSeconds_1: Optional[MaximumBatchingWindowInSeconds] = Field(
        None, alias='MaximumBatchingWindowInSeconds'
    )
    MaximumRecordAgeInSeconds_1: Optional[MaximumRecordAgeInSeconds] = Field(
        None, alias='MaximumRecordAgeInSeconds'
    )
    MaximumRetryAttempts: Optional[MaximumRetryAttemptsEventSourceMapping] = None
    ParallelizationFactor_1: Optional[ParallelizationFactor] = Field(
        None, alias='ParallelizationFactor'
    )
    Queues_1: Optional[Queues] = Field(None, alias='Queues')
    ScalingConfig_1: Optional[ScalingConfig] = Field(None, alias='ScalingConfig')
    SelfManagedEventSource_1: Optional[SelfManagedEventSource] = Field(
        None, alias='SelfManagedEventSource'
    )
    SelfManagedKafkaEventSourceConfig_1: Optional[SelfManagedKafkaEventSourceConfig] = (
        Field(None, alias='SelfManagedKafkaEventSourceConfig')
    )
    SourceAccessConfigurations_1: Optional[SourceAccessConfigurations] = Field(
        None, alias='SourceAccessConfigurations'
    )
    StartingPosition: Optional[EventSourcePosition] = None
    StartingPositionTimestamp: Optional[Date] = None
    Topics_1: Optional[Topics] = Field(None, alias='Topics')
    TumblingWindowInSeconds_1: Optional[TumblingWindowInSeconds] = Field(
        None, alias='TumblingWindowInSeconds'
    )


class EventSourceMappingConfiguration(BaseModel):
    AmazonManagedKafkaEventSourceConfig_1: Optional[
        AmazonManagedKafkaEventSourceConfig
    ] = Field(None, alias='AmazonManagedKafkaEventSourceConfig')
    BatchSize_1: Optional[BatchSize] = Field(None, alias='BatchSize')
    BisectBatchOnFunctionError_1: Optional[BisectBatchOnFunctionError] = Field(
        None, alias='BisectBatchOnFunctionError'
    )
    DestinationConfig_1: Optional[DestinationConfig] = Field(
        None, alias='DestinationConfig'
    )
    DocumentDBEventSourceConfig_1: Optional[DocumentDBEventSourceConfig] = Field(
        None, alias='DocumentDBEventSourceConfig'
    )
    EventSourceArn: Optional[Arn] = None
    FilterCriteria_1: Optional[FilterCriteria] = Field(None, alias='FilterCriteria')
    FunctionArn_1: Optional[FunctionArn] = Field(None, alias='FunctionArn')
    FunctionResponseTypes: Optional[FunctionResponseTypeList] = None
    LastModified: Optional[Date] = None
    LastProcessingResult: Optional[String] = None
    MaximumBatchingWindowInSeconds_1: Optional[MaximumBatchingWindowInSeconds] = Field(
        None, alias='MaximumBatchingWindowInSeconds'
    )
    MaximumRecordAgeInSeconds_1: Optional[MaximumRecordAgeInSeconds] = Field(
        None, alias='MaximumRecordAgeInSeconds'
    )
    MaximumRetryAttempts: Optional[MaximumRetryAttemptsEventSourceMapping] = None
    ParallelizationFactor_1: Optional[ParallelizationFactor] = Field(
        None, alias='ParallelizationFactor'
    )
    Queues_1: Optional[Queues] = Field(None, alias='Queues')
    ScalingConfig_1: Optional[ScalingConfig] = Field(None, alias='ScalingConfig')
    SelfManagedEventSource_1: Optional[SelfManagedEventSource] = Field(
        None, alias='SelfManagedEventSource'
    )
    SelfManagedKafkaEventSourceConfig_1: Optional[SelfManagedKafkaEventSourceConfig] = (
        Field(None, alias='SelfManagedKafkaEventSourceConfig')
    )
    SourceAccessConfigurations_1: Optional[SourceAccessConfigurations] = Field(
        None, alias='SourceAccessConfigurations'
    )
    StartingPosition: Optional[EventSourcePosition] = None
    StartingPositionTimestamp: Optional[Date] = None
    State: Optional[String] = None
    StateTransitionReason: Optional[String] = None
    Topics_1: Optional[Topics] = Field(None, alias='Topics')
    TumblingWindowInSeconds_1: Optional[TumblingWindowInSeconds] = Field(
        None, alias='TumblingWindowInSeconds'
    )
    UUID: Optional[String] = None


class EventSourceMappingsList(RootModel[List[EventSourceMappingConfiguration]]):
    root: List[EventSourceMappingConfiguration]


class FunctionConfiguration(BaseModel):
    Architectures: Optional[ArchitecturesList] = None
    CodeSha256: Optional[String] = None
    CodeSize: Optional[Long] = None
    DeadLetterConfig_1: Optional[DeadLetterConfig] = Field(
        None, alias='DeadLetterConfig'
    )
    Description_1: Optional[Description] = Field(None, alias='Description')
    Environment: Optional[EnvironmentResponse] = None
    EphemeralStorage_1: Optional[EphemeralStorage] = Field(
        None, alias='EphemeralStorage'
    )
    FileSystemConfigs: Optional[FileSystemConfigList] = None
    FunctionArn: Optional[NameSpacedFunctionArn] = None
    FunctionName: Optional[NamespacedFunctionName] = None
    Handler_1: Optional[Handler] = Field(None, alias='Handler')
    ImageConfigResponse_1: Optional[ImageConfigResponse] = Field(
        None, alias='ImageConfigResponse'
    )
    KMSKeyArn_1: Optional[KMSKeyArn] = Field(None, alias='KMSKeyArn')
    LastModified: Optional[Timestamp] = None
    LastUpdateStatus_1: Optional[LastUpdateStatus] = Field(
        None, alias='LastUpdateStatus'
    )
    LastUpdateStatusReason_1: Optional[LastUpdateStatusReason] = Field(
        None, alias='LastUpdateStatusReason'
    )
    LastUpdateStatusReasonCode_1: Optional[LastUpdateStatusReasonCode] = Field(
        None, alias='LastUpdateStatusReasonCode'
    )
    Layers: Optional[LayersReferenceList] = None
    MasterArn: Optional[FunctionArn] = None
    MemorySize_1: Optional[MemorySize] = Field(None, alias='MemorySize')
    PackageType_1: Optional[PackageType] = Field(None, alias='PackageType')
    RevisionId: Optional[String] = None
    Role: Optional[RoleArn] = None
    Runtime_1: Optional[Runtime] = Field(None, alias='Runtime')
    RuntimeVersionConfig_1: Optional[RuntimeVersionConfig] = Field(
        None, alias='RuntimeVersionConfig'
    )
    SigningJobArn: Optional[Arn] = None
    SigningProfileVersionArn: Optional[Arn] = None
    SnapStart: Optional[SnapStartResponse] = None
    State_1: Optional[State] = Field(None, alias='State')
    StateReason_1: Optional[StateReason] = Field(None, alias='StateReason')
    StateReasonCode_1: Optional[StateReasonCode] = Field(None, alias='StateReasonCode')
    Timeout_1: Optional[Timeout] = Field(None, alias='Timeout')
    TracingConfig: Optional[TracingConfigResponse] = None
    Version_1: Optional[Version] = Field(None, alias='Version')
    VpcConfig: Optional[VpcConfigResponse] = None


class FunctionList(RootModel[List[FunctionConfiguration]]):
    root: List[FunctionConfiguration]


class GetFunctionResponse(BaseModel):
    Code: Optional[FunctionCodeLocation] = None
    Concurrency_1: Optional[Concurrency] = Field(None, alias='Concurrency')
    Configuration: Optional[FunctionConfiguration] = None
    Tags_1: Optional[Tags] = Field(None, alias='Tags')


class ListEventSourceMappingsResponse(BaseModel):
    EventSourceMappings: Optional[EventSourceMappingsList] = None
    NextMarker: Optional[String] = None


class ListFunctionsResponse(BaseModel):
    Functions: Optional[FunctionList] = None
    NextMarker: Optional[String] = None


class ListProvisionedConcurrencyConfigsResponse(BaseModel):
    NextMarker: Optional[String] = None
    ProvisionedConcurrencyConfigs: Optional[ProvisionedConcurrencyConfigList] = None


class ListVersionsByFunctionResponse(BaseModel):
    NextMarker: Optional[String] = None
    Versions: Optional[FunctionList] = None
